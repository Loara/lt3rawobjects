% \iffalse meta-comment
%
%  lt3rawobjects Objects and proxies in LaTeX3
%  Copyright (C) 2022-2023  Paolo De Donato <dedonato95@hotmail.it>
%
%  This file is part of lt3rawobjects.
%
%  lt3rawobjects is free software: you can redistribute it and/or modify
%  it under the terms of the GNU General Public License as published by
%  the Free Software Foundation, either version 3 of the License, or
%  (at your option) any later version.
%
%  lt3rawobjects is distributed in the hope that it will be useful,
%  but WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  GNU General Public License for more details.
%
%  You should have received a copy of the GNU General Public License
%  along with lt3rawobjects.  If not, see <https://www.gnu.org/licenses/>.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{lt3rawobjects.dtx}[2023/03/17 2.4 Objects and proxies in LaTeX3]
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}
%<package>\RequirePackage{expl3}[2022-04-10]
%<package>\ProvidesExplPackage{lt3rawobjects}{2023/03/17}{ 2.4 }{Objects and proxies in LaTeX3}
%<*driver>
\documentclass[full]{l3doc}
\usepackage{lt3rawobjects}
\usepackage{xparse}
\usepackage{xcolor}
\usepackage{fancyvrb}
\begin{document}


\DocInput{lt3rawobjects.dtx}
\end{document}
%</driver>
% \fi
%
% \NewDocumentCommand{\thpkg}{}{\pkg{lt3rawobjects}}
% \NewDocumentCommand{\thvsn}{}{2.4}
% \NewDocumentCommand{\thdta}{}{2023/03/17}
% \NewDocumentCommand{\fromV}{ m }{{\ttfamily From: #1}}
% \NewDocumentCommand{\fromVD}{ m m }{{\ttfamily From: #1}\par {\ttfamily Deprecated in: #2}}
% \NewDocumentCommand{\virg}{ m }{``#1''}
%
% \NewDocumentCommand{\simfun}{m m}{\textcolor{blue}{\textbackslash #1}\textcolor{purple}{:#2}}
% \NewDocumentCommand{\simvar}{m}{\textcolor{violet}{\textbackslash #1}}
% \DefineVerbatimEnvironment{Coding}{Verbatim}{numbers=left, frame=single, commandchars={![]}}
%
% \title{The \pkg{lt3rawobjects} package}
%   \author{Paolo De Donato}
%   \date{Released on \thdta\ Version \thvsn}
%
% \maketitle
%
% \tableofcontents
%
% \begin{documentation}
%
% \section{Introduction}
% Package \thpkg\ introduces a new mechanism to create and manage structured data called ``objects'' like the well known C structures. The functions exported by this package are quite low level, and many important mechanisms like member protection and name resolution aren't already defined and should be introduced by intermediate packages. Higher level libraries built on top of \thpkg\ could also implement an improved and simplified syntax since the main focus of \thpkg\ is versatility and expandability rather than common usage.
%
% This packages follows the \href{https://semver.org/}{SemVer} specification (\texttt{https://semver.org/}). In particular any major version update (for example from \texttt{1.2} to \texttt{2.0}) may introduce imcompatible changes and so it's not advisable to work with different packages that require different major versions of \thpkg. Instead changes introduced in minor and patch version updates are always backward compatible, and any withdrawn function is declared deprecated instead of being removed.
%
% \section{Addresses}
% In this package a \emph{pure address} is any string without spaces (so a sequence of tokens with category code 12 ``other'') that uniquely identifies a resource or an entity. An example of pure address if the name of a control sequence \tn{\meta{name}} that can obtained by full expanding \cs{cs_to_str:N} \tn{\meta{name}}. Instead an \emph{expanded address} is a token list that contains only tokens with category code 11 (letters) or 12 (other) that can be directly converted to a pure address with a simple call to \cs{tl_to_str:n} or by assigning it to a string variable.
%
% An \emph{address} is instead a fully expandable token list which full expansion is a pure address, where full expansion means the expansion process performed inside |c|, |x| and |e| parameters. Moreover, any address should be fully expandable according to the rules of |x| and |e| parameter types with same results, and the name of control sequence resulting from a |c|-type expansion of such address must be equal to its full expansion. For these reasons addresses should not contain parameter tokens like |#| (because they're threat differently by |x| and |e|) or control sequences that prevents expansion like \cs{exp_not:n} (because they leave unexpanded control sequences after an |x| or |e| expansion, and expanded addresses can't have control sequences inside them). In particular, |\tl_to_str:n{ ## }| is \emph{not} a valid address (assuming standard category codes).
%
% Addresses could be not full expanded inside an |f| argument, thus an address expanded in an |f| argument should be |x|, |e| or |c| expended later to get the actual pure address. If you need to fully expand an address in an |f| argument (because, for example, your macro should be fully expandable and your engine is too old to support |e| expansion efficiently) then you can put your address inside \cs{rwobj_address_f:n} and pass them to your function. For example,
% \begin{verbatim}
%   \your_function:f{ \rwobj_address_f:n { your \address } } 
% \end{verbatim}
% Remember that \cs{rwobj_address_f:n} only works with addresses, can't be used to fully expand any token list.
%
% Like functions and variables names, pure addresses should follows some basic naming conventions in order to avoid clashes between addresses in different modules. Each pure address starts with the \meta{module} name in which such address is allocated, then an underscore (|_|) and the \meta{identifier} that uniquely identifies the resource inside the module. The \meta{module} should contain only lowercase ASCII letters.
%
% A \emph{pointer} is just a \LaTeX3 string variable that holds a pure address. We don't enforce to use |str| or any special suffix to denote pointers so you're free to use |str| or a custom \meta{type} as suffix for your pointers in order to distinguish between them according to their type.
%
% In \thpkg\ all the macros ending with |_adr| or |_address| are fully expandable and can be used to compose valid addresses as explained later in this document.
%
% \section{Address spaces and objects}
% Since in \LaTeX3 all the functions and variables are declared globally a package mantainer can't just allocate its resources on a random address in order to avoid possible clashes between independent packages. Moreover, a lot of packages need to create new resources during document composition from an user input. Since the user is not aware of the implementation the package owner should insure that any user input doesn't try to allocate new resources on already taken addresses.
%
% For these reasons each address should be contained inside an \emph{address space} which is just a string that avoid clashes between resources. More precisely, the address of a function should have the following form:
% \begin{Coding}
%   !meta[address space]_!meta[function name]:!meta[arguments]
% \end{Coding}
% whereas the address of variables and constants should be
% \begin{Coding}
%   !meta[scope]_!meta[address space]_!meta[variable name]_!meta[type]
% \end{Coding}
% where \meta{scope} is one of |g|, |l|, |c|.
%
% More precisely, an address space consists in a sequence of one or more nonempty alphanumeric strings, called \emph{address names}, separated by dots (|.|). For example 
% \begin{Coding}
%   mod1
%   A.b2
%   pp.9.12w
% \end{Coding}
% are all valid address spaces. The leftmost address name in an address space is also called \emph{module name} and should uniquely identify the entire package: different \LaTeX3 packages can't have the same module name. An address space that has only the module name is also called \emph{primary address space} or \emph{module space}. Any other address name that follows the module name are called \emph{subspace names}. For example in the address space |mod.2.ap| the module name is |mod| whereas |2| and |ap| are subspace names.
%
% An address space is comtained in another one if and only if the first one contains all the address names of the second in the same order, for example |AA.BB.CC| is contained in |AA| and in |AA.BB| but not in |CC|, |AA.B| or in |AA.BB.CC.E|.
%
% An address space can also be seen as a container that holds macros/variables/functions that share common functionalities. For example if you want to store the coordinated of a three dimensional point you can put them inside three variables contained in a subspace of your module space, in this way the resulting address space will represent your original point.
%
% You can even pass an address space to a different package by just passing its name as a token list/string, but you and the destination package should before agree upon a common protocol in order to make the passed address space understandable. You can clearly make your own protocol for address spaces exchanging, but \thpkg\ already introduces a valid exchanging protocol that you would use in your project.
%  
% An address space that follows the exchanging protocol defined in \thpkg\ is called \emph{object}. All the macros/variables/constants/functions/subspaces contained in an object are also called \emph{fields}. Objects and fields should be always created with functions defined in this package. Remember that objects are also address spaces, so you can identify them by their address space name. Such string can be seen also as a pure address that points to your object and so it'll be called also \emph{object address}.
%
% \section{Proxy}
% Instead of generic address spaces, objects should be created before to use them. In order to create a new object you should uuse a particular kind of object that holds all the necessary information to instantiate your object. These objects that are needed to instantiate new objects are called \emph{proxy}, and the proxy used to instantiated an object is its \emph{generator}. Every object knows the address of its generator.
%
% For example the proxy |rwobj_empty| can be used to create empty objects, which are objects that contains only the required fields needed by the exchanging protocol. However, you can create your own proxy that initialized your object fields as you wish. To create new proxies you can use the proxy |rwobj_proxygen|.
%
% Proxy can also be used as interfaces to group objects by common utilities. Indeed you can use the function \cs{rwobj_proxy_test_eq:nn} to test if an object has been created with the selected proxy.
%
% \section{Fields}
% Currently objects can contain as fields the following entities:
% \begin{itemize}
%   \item \LaTeX3 variables, which are also called \emph{member};
%   \item \LaTeX3 constants, which are also called \emph{constant};
%   \item \LaTeX3 functions, which are also called \emph{method};
%   \item generic control sequences, which are also called \emph{macros}.
% \end{itemize}
%
% Fields in an object are put inside different address spaces (contained in the object address) in order to avoid name clashes with hidden fields required by the exchanging protocol. For this reason you should always use function in the form \cs{rwobj_\meta{field kind}_adr} to get the appropriate field address. 
%
% Objects could be declared \emph{local} or \emph{global}. The only difference between a local and a global object is the scope of their members (that are \LaTeX3 variables). You should always create global object unless you specifically need local members.
%
% \subsection{Constants}
% Constants in an object could be \emph{near} and \emph{remote}. A near constant is just a constant declared in such object and could be referred only by it, instead a remote constant is declared inside its generator and can be referred by any object created from that proxy, thus it's shared between all the generated objects. Functions in this library that work with near constants usually contain |nconstant| in their names, whereas those involving remore constants contain |rconstant| instead.
%
% Both near and remote constants are created in the same way via the |_newconst| functions, however remote constant should be created in a proxy whereas near contant are created directly in the target object.
%
% \subsection{Methods}
% Methods are \LaTeX3 functions that can't be changed once they're created. Like constant, methods could be near or remote. Moreover, functions in this library dealing with near methods contain |nmethod| whereas those dealing with remote methods contain |rmethod| in their names. 
%
% \subsection{Members}
% Members are just mutable \LaTeX3 variables. You can manually create new members in already existing objects or you can put the definition of a new member directly in a proxy with the \cs{rwobj_proxy_push_member} functions. In this way all the objects created with that proxy will have a member according to such definition. If the object is local/global then all its members are automatically local/global.
%
% A member can be \emph{tracked} or \emph{not tracked}. A tracked member have additional information, like its type, stored in the object or in its generator. In particular, you don't need to specify the type of a tracked member and some functions in \thpkg\ are able to retrieve the required information. All the members declared in the generator are automatically tracked.
%
% \section{Embedded object}
% Objects can be created inside other objects by just using an address space contained in the parent object address, for example an object created at the address |mod.A.B| is automatically contained in the object at address |mod.A|. A contained object is independent from the contained, imparticular they can have different scope.
%
% An \emph{embedded object} is not just an object instantiated in a parent object, but it also inherit some properties of the parent object like the scope. Embedded objects are created via \cs{rwobj_new_embedded} functions.
%
% \section{Library functions}
% \label{sec:lib}
%
%  \subsection{Common functions}
%
% \begin{function}[EXP]{\rwobj_address_f:n}
%  \begin{syntax}
%   \cs{rwobj_address_f:n} \Arg{address}
%  \end{syntax}
%  Fully expand an address in an |f|-type argument.
%
%  \fromV{2.3}
% \end{function}
%
%  \subsection{Base object functions}
%
% \begin{function}[pTF]{\rwobj_object_if_exist:n, \rwobj_object_if_exist:V}
%  \begin{syntax}
%   \cs{rwobj_object_if_exist_p:n} \Arg{address}
%   \cs{rwobj_object_if_exist:nTF} \Arg{address} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if an object was instantiated at the specified address.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}[EXP]{\rwobj_object_get_module:n, \rwobj_object_get_module:V, \rwobj_object_get_proxy:n, \rwobj_object_get_proxy:V}
%  \begin{syntax}
%   \cs{rwobj_object_get_module:n} \Arg{address}
%   \cs{rwobj_object_get_proxy:n} \Arg{address}
%  \end{syntax}
%  Get the object module and its generator.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}[pTF]{\rwobj_object_if_local:n, \rwobj_object_if_global:n, \rwobj_object_if_local:V, \rwobj_object_if_global:V}
%  \begin{syntax}
%   \cs{rwobj_object_if_local_p:n} \Arg{address}
%   \cs{rwobj_object_if_local:nTF} \Arg{address} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if the object is local or global.
%
% \fromV{2.4}
% \end{function}
%
%  \subsection{Members}
%
% \begin{function}[rEXP]{\rwobj_member_adr:nnn, \rwobj_member_adr:Vnn, \rwobj_member_adr:nnv, \rwobj_member_adr:nn, \rwobj_member_adr:Vn}
%  \begin{syntax}
%   \cs{rwobj_member_adr:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%   \cs{rwobj_member_adr:nn} \Arg{address} \Arg{member name}
%  \end{syntax}
%  Fully expands to the address of specified member variable. If the member is tracked then you can omit the type field.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}[pTF]{\rwobj_member_if_exist:nnn, \rwobj_member_if_exist:Vnn}
%  \begin{syntax}
%   \cs{rwobj_member_if_exist_p:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%   \cs{rwobj_member_if_exist:nnnTF} \Arg{address} \Arg{member name} \Arg{member type} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if the specified member exist.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}[pTF]{\rwobj_member_if_tracked:nn, \rwobj_member_if_tracked:Vn}
%  \begin{syntax}
%   \cs{rwobj_member_if_tracked_p:nn} \Arg{address} \Arg{member name}
%   \cs{rwobj_member_if_tracked:nnTF} \Arg{address} \Arg{member name} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if the specified member exist and is tracked.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}[EXP]{\rwobj_member_type:nn, \rwobj_member_type:Vn}
%  \begin{syntax}
%   \cs{rwobj_member_type:nn} \Arg{address} \Arg{member name}
%  \end{syntax}
%  Fully expands to the type of specified tracked member.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}{\rwobj_new_member:nnn, \rwobj_new_member:Vnn, \rwobj_new_member:nnv}
%  \begin{syntax}
%   \cs{rwobj_new_member:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%  \end{syntax}
%  Creates a new member with specified name and type. The created member is not tracked.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}{\rwobj_new_member_tracked:nnn, \rwobj_new_member_tracked:Vnn}
%  \begin{syntax}
%   \cs{rwobj_new_member_tracked:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%  \end{syntax}
%  Creates a new tracked member.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}[EXP]{\rwobj_member_use:nnn, \rwobj_member_use:Vnn, \rwobj_member_use:nnv, \rwobj_member_use:nn, \rwobj_member_use:Vn}
%  \begin{syntax}
%   \cs{rwobj_member_use:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%   \cs{rwobj_member_use:nn} \Arg{address} \Arg{member name}
%  \end{syntax}
%  Uses the specified member variable.
%
% \fromV{2.4}
% \end{function}
%
% \begin{function}{\rwobj_member_set:nnnn, \rwobj_member_set:nnvn, \rwobj_member_set:Vnnn, \rwobj_member_set:nnn, \rwobj_member_set:Vnn}
%  \begin{syntax}
%   \cs{rwobj_member_set:nnnn} \Arg{address} \Arg{member name} \Arg{member type} \Arg{value}
%   \cs{rwobj_member_set:nnn} \Arg{address} \Arg{member name} \Arg{value}
%  \end{syntax}
%  Sets the value of specified member to \marg{value}. It calls implicitly \cs{\meta{member type}_(g)set:cn} then be sure to define it before calling this method.
%
% \fromV{2.1}
% \end{function}
%
% \begin{function}{\rwobj_member_set_eq:nnnN, \rwobj_member_set_eq:nnvN, \rwobj_member_set_eq:VnnN, \rwobj_member_set_eq:nnnc, \rwobj_member_set_eq:Vnnc, \rwobj_member_set_eq:nnN, \rwobj_member_set_eq:VnN, \rwobj_member_set_eq:nnc, \rwobj_member_set_eq:Vnc}
%  \begin{syntax}
%   \cs{rwobj_member_set_eq:nnnN} \Arg{address} \Arg{member name} \Arg{member type} \meta{variable}
%   \cs{rwobj_member_set_eq:nnN} \Arg{address} \Arg{member name} \meta{variable}
%  \end{syntax}
%  Sets the value of specified member equal to the value of \meta{variable}.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\rwobj_member_generate:NN, \rwobj_member_generate_protected:NN}
%  \begin{syntax}
%   \cs{rwobj_member_generate:NN} \cs{\meta{name\textsubscript{1}}} \cs{\meta{name\textsubscript{2}}:\meta{arg1}\meta{args}}
%  \end{syntax}
%  Define the new functions \cs{\meta{name\textsubscript{1}}:nnn\meta{Targs} } and \cs{\meta{name\textsubscript{1}}:nn\meta{Targs} } that pass to \cs{\meta{name\textsubscript{2}}:\meta{arg1}\meta{args} } the specified member address as the first argument. \meta{Targs} is a list of argument specifications obtained by transforming each element of \meta{args} to |n|, |N|, |w|, |T| or |F|.
%
% The first three parameters of \cs{\meta{name\textsubscript{1}}:nnn\meta{args} } should be in the following order:
%  \begin{enumerate}
%    \item an object address;
%    \item a member name;
%    \item the type of specified member.
%  \end{enumerate}
%
%  Function \cs{\meta{name\textsubscript{1}}:nn\meta{args} } only accepts the first two parameters and works only with tracked members. Notice that \meta{arg1} must be only one of the following: |n|, |c|, |v|, |x|, |f|, |e|, |o|.
%
% \fromV{2.3}
% \end{function}
%
% \begin{function}{\rwobj_member_generate_inline:Nnn, \rwobj_member_generate_protected_inline:Nnn}
%  \begin{syntax}
%   \cs{rwobj_member_generate_inline:Nnn} \cs{\meta{name\textsubscript{1}}} \Arg{name\textsubscript{2}} \{\meta{arg1}\meta{args}\}
%  \end{syntax}
%  Works as \cs{rwobj_member_generate:NN}, however in \meta{name\textsubscript{2}} you can use parameters |#1| and |#2| to compose the needed function. Parameter |#1| expands to the (fully expanded) member type and |#2| is equal to |g| if the object is global and it's empty if it is local.
%
% \fromV{2.3}
% \end{function}
%
% \subsection{Constants}
% \begin{function}[rEXP]{\rwobj_nconstant_adr:nnn, \rwobj_nconstant_adr:Vnn, \rwobj_nconstant_adr:vnn, \rwobj_rconstant_adr:nnn, \rwobj_rconstant_adr:Vnn}
%  \begin{syntax}
%   \cs{rwobj_nconstant_adr:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%  \end{syntax}
%  Fully expands to the address of specified near/remote constant member.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[pTF]{\rwobj_nconstant_if_exist:nnn, \rwobj_nconstant_if_exist:Vnn, \rwobj_rconstant_if_exist:nnn, \rwobj_rconstant_if_exist:Vnn}
%  \begin{syntax}
%   \cs{rwobj_nconstant_if_exist_p:nnn} \marg{address} \marg{member name} \marg{member type}
%   \cs{rwobj_nconstant_if_exist:nnnTF} \marg{address} \marg{member name} \marg{member type} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if the specified member constant exist.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[EXP]{\rwobj_nconstant_use:nnn, \rwobj_nconstant_use:Vnn, \rwobj_rconstant_use:nnn, \rwobj_rconstant_use:Vnn}
%  \begin{syntax}
%   \cs{rwobj_nconstant_use:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%  \end{syntax}
%  Uses the specified near/remote constant member.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}{\rwobj_nconstant_generate:NN, \rwobj_nconstant_protected_generate:NN, \rwobj_rconstant_generate:NN, \rwobj_rconstant_protected_generate:NN}
%  \begin{syntax}
%   \cs{rwobj_nconstant_generate:NN} \cs{\meta{name\textsubscript{1}}} \cs{name\textsubscript{2}}:\meta{arg1}\meta{args}
%  \end{syntax}
%  Works as \cs{rwobj_member_generate:NN} but with constants instead of members.
%
%  \fromV{2.3}
% \end{function}
%
% \begin{function}{\rwobj_nconstant_generate_inline:Nnn, \rwobj_nconstant_protected_generate_inline:Nnn, \rwobj_rconstant_generate_inline:Nnn, \rwobj_rconstant_protected_generate_inline:Nnn}
%  \begin{syntax}
%   \cs{rwobj_nconstant_generate_inline:Nnn} \cs{\meta{name\textsubscript{1}}} \Arg{name\textsubscript{2}} \{\meta{arg1}\meta{args}\}
%  \end{syntax}
%  Works as \cs{rwobj_member_generate_inline:Nnn} but with constants instead of members.
%
%  \fromV{2.3}
% \end{function}
%
% \subsection{Methods}
% \begin{function}[rEXP]{\rwobj_nmethod_adr:nnn, \rwobj_nmethod_adr:Vnn, \rwobj_nmethod_adr:vnn, \rwobj_rmethod_adr:nnn, \rwobj_rmethod_adr:Vnn}
%  \begin{syntax}
%   \cs{rwobj_nmethod_adr:nnn} \Arg{address} \Arg{method name} \Arg{method variant}
%  \end{syntax}
%  Fully expands to the address of the specified
%  \begin{itemize}
%    \item near constant method if \cs{rwobj_nmethod_adr} is used;
%    \item remote constant method if \cs{rwobj_rmethod_adr} is used.
%  \end{itemize}
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[pTF]{\rwobj_nmethod_if_exist:nnn, \rwobj_nmethod_if_exist:Vnn, \rwobj_rmethod_if_exist:nnn, \rwobj_rmethod_if_exist:Vnn}
%  \begin{syntax}
%   \cs{rwobj_nmethod_if_exist_p:nnn} \marg{address} \marg{method name} \marg{method variant}
%   \cs{rwobj_nmethod_if_exist:nnnTF} \marg{address} \marg{method name} \marg{method variant} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if the specified method constant exist.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}{\rwobj_new_method:nnnn, \rwobj_new_method:Vnnn}
%  \begin{syntax}
%   \cs{rwobj_new_method:nnnn} \Arg{address} \Arg{method name} \Arg{method arguments} \Arg{code}
%  \end{syntax}
%  Creates a new method with specified name and argument types. The \marg{method arguments} should be a string composed only by |n| and |N| characters that are passed to \cs{cs_new:Nn}.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[EXP]{\rwobj_nmethod_call:nnn, \rwobj_nmethod_call:Vnn, \rwobj_rmethod_call:nnn, \rwobj_rmethod_call:Vnn}
%  \begin{syntax}
%   \cs{rwobj_nmethod_call:nnn} \marg{address} \marg{method name} \marg{method variant}
%  \end{syntax}
%  Calls the specified method. This function is expandable if and only if the specified method was not declared |protected|.
%
% \fromV{2.0}
% \end{function}
%
% \subsection{Creation of constants}
% \begin{function}{\rwobj_new_constant_tl:nnn, \rwobj_new_constant_tl:Vnn, \rwobj_new_constant_str:nnn, \rwobj_new_constant_str:Vnn, \rwobj_new_constant_int:nnn, \rwobj_new_constant_int:Vnn, \rwobj_new_constant_clist:nnn, \rwobj_new_constant_clist:Vnn, \rwobj_new_constant_dim:nnn, \rwobj_new_constant_dim:Vnn, \rwobj_new_constant_skip:nnn, \rwobj_new_constant_skip:Vnn, \rwobj_new_constant_fp:nnn, \rwobj_new_constant_fp:Vnn}
%  \begin{syntax}
%   \cs{rwobj_new_constant_\meta{type}:nnn} \Arg{address} \Arg{constant name} \Arg{value}
%  \end{syntax}
%  Creates a constant variable with type \meta{type} and sets its value to \meta{value}.
%
%  \fromV{1.1}
% \end{function}
%
% \begin{function}{\rwobj_new_constant_seq_from_clist:nnn, \rwobj_new_constant_seq_from_clist:Vnn}
%  \begin{syntax}
%   \cs{rwobj_new_constant_seq_from_clist:nnn} \Arg{address} \Arg{constant name} \Arg{comma-list}
%  \end{syntax}
%  Creates a |seq| constant which is set to contain all the items in \meta{comma-list}.
%
% \fromV{1.1}
% \end{function}
%
% \begin{function}{\rwobj_new_constant_prop_from_keyval:nnn, \rwobj_new_constant_prop_from_keyval:Vnn}
%  \begin{syntax}
%   \cs{rwobj_new_constant_prop_from_keyval:nnn} \Arg{address} \Arg{constant name}
%   \{
%   \meta{key} = \meta{value}, ...
%   \}
%  \end{syntax}
%  Creates a |prop| constant which is set to contain all the specified key-value pairs.
%
% \fromV{1.1}
% \end{function}
%
% \begin{function}{\rwobj_new_constant:nnnn}
%  \begin{syntax}
%   \cs{rwobj_new_constant:nnnn} \Arg{address} \Arg{constant name} \Arg{type} \Arg{value}
%  \end{syntax}
%  Invokes \cs{\meta{type}_const:cn} to create the specified constant.
%
%  \fromV{2.1}
% \end{function}
%
% \subsection{Macros}
% \begin{function}[rEXP]{\rwobj_macro_adr:nn, \rwobj_macro_adr:Vn}
%  \begin{syntax}
%   \cs{rwobj_macro_adr:nn} \Arg{address} \Arg{macro name}
%  \end{syntax}
%  Address of specified macro.
%
%  \fromV{2.2}
% \end{function}
% 
% \begin{function}[EXP]{\rwobj_macro_use:nn, \rwobj_macro_use:Vn}
%  \begin{syntax}
%   \cs{rwobj_macro_use:nn} \Arg{address} \Arg{macro name}
%  \end{syntax}
%  Uses the specified macro. This function is expandable if and only if the specified macro is it.
%
%  \fromV{2.2}
% \end{function}
%
% There isn't any standard function to create macros, and macro declarations can't be inserted in a |proxy| object. In fact a macro is just an unspecialized control sequence at the disposal of users that usually already know how to implement them. 
%
% \subsection{Proxies and object creation}
%
% \begin{function}[pTF]{\rwobj_object_if_proxy:n, \rwobj_object_if_proxy:V}
%  \begin{syntax}
%   \cs{rwobj_object_if_proxy_p:n} \Arg{address}
%   \cs{rwobj_object_if_proxy:nTF} \Arg{address} \marg{true code} \marg{false code}
%  \end{syntax}
%  Test if the specified object is a proxy object.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}[pTF]{\rwobj_object_test_generator:nn, \rwobj_object_test generator:Vn}
%  \begin{syntax}
%   \cs{rwobj_object_test_generator_p:nn} \Arg{object address} \Arg{proxy address}
%   \cs{rwobj_object_test_generator:nnTF} \Arg{object address} \Arg{proxy address} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Test if the specified object is generated by the selected proxy.
%
% \begin{texnote}
% Remember that this command uses internally an |e| expansion so in older engines (any different from Lua\LaTeX\ before 2019) it'll require slow processing. Don't use it in speed critical parts, instead use \cs{rwobj_test_proxy:nN}.
% \end{texnote}
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[pTF]{\rwobj_object_test_generator:nN, \rwobj_object_test_generator:VN}
%  \begin{syntax}
%   \cs{rwobj_object_test_generator_p:nN} \Arg{object address} \meta{proxy variable}
%   \cs{rwobj_object_test_generator:nNTF} \Arg{object address} \meta{proxy variable} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Test if the specified object is generated by the selected proxy, where \meta{proxy variable} is a string variable holding the proxy address. The |:nN| variant don't use |e| expansion, instead of |:nn| command, so it can be safetly used with older compilers. 
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}{\rwobj_new_object:nnN, \rwobj_new_object:VnN, \rwobj_new_object:nn, \rwobj_new_object:Vn}
%  \begin{syntax}
%   \cs{rwobj_new_object:nnN} \Arg{proxy address} \Arg{object address} \meta{scope}\\
%   \cs{rwobj_new_object:nn} \Arg{proxy address} \Arg{object address}
%  \end{syntax}
%  Creates a new local/global object at specified address. If you don't specify the scope the object is automatically global.
%
% \fromV{2.3}
% \end{function}
%
% \begin{function}{\rwobj_new_embedded:nn, \rwobj_new_embedded:Vn, \rwobj_new_embedded:nv}
%  \begin{syntax}
%   \cs{rwobj_new_embedded:nn} \Arg{object address} \Arg{proxy address}
%  \end{syntax}
%  Creates an embedded object.
%
% \fromV{2.2}
% \end{function}
%
% \begin{variable}{\c_rwobj_local_str, \c_rwobj_global_str}
%  Possible values for \meta{scope} parameter.
%
% \fromV{1.0}
% \end{variable}
%
% \begin{function}{\rwobj_new_object_set:NnnN, \rwobj_new_object_set:NVnN, \rwobj_new_object_gset:NnnN, \rwobj_new_object_gset:NVnN}
%  \begin{syntax}
%   \cs{rwobj_new_object_set:NnnN} \meta{str var} \Arg{proxy address} \Arg{object address} \meta{scope}
%  \end{syntax}
%  Creates an object and sets its fully expanded address inside \meta{str var}.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\rwobj_proxy_create:n, \rwobj_proxy_create_set:Nn, \rwobj_proxy_create_gset:Nn}
%  \begin{syntax}
%   \cs{rwobj_proxy_create:n} \Arg{proxy address}
%   \cs{rwobj_proxy_create_set:Nn} \meta{str var} \Arg{proxy address}
%  \end{syntax}
%  Creates a global public proxy object.
%
% \fromV{2.3}
% \end{function}
%
% \begin{function}{\rwobj_proxy_push_member:nnn, \rwobj_proxy_push_member:Vnn}
%  \begin{syntax}
%   \cs{rwobj_proxy_push_member:nnn} \Arg{proxy address} \Arg{member name} \Arg{member type}
%  \end{syntax}
%  Updates a proxy object with a new member specification, so that every subsequential object created with this proxy will have a member variable with the specified name and type that can be retrieved with \cs{rwobj_member_type} functions.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\rwobj_proxy_push_embedded:nnn, \rwobj_proxy_push_embedded:Vnn}
%  \begin{syntax}
%   \cs{rwobj_proxy_push_embedded:nnn} \Arg{proxy address} \Arg{embedded object name} \Arg{embedded object proxy}
%  \end{syntax}
%  Updates a proxy object with a new embedded object specification.
%
% \fromV{2.2}
% \end{function}
%
% \begin{function}{\rwobj_proxy_add_initializer:nN, \rwobj_proxy_add_initializer:VN}
%  \begin{syntax}
%   \cs{rwobj_proxy_add_initializer:nN} \Arg{proxy address} \meta{initializer}
%  \end{syntax}
%  Pushes a new initializer that will be executed on each created objects. An initializer is a function that should accept five arguments in this order:
%  \begin{itemize}
%   \item the full expanded address of used proxy as an |n| argument;
%   \item the module name as an |n| argument;
%   \item the full expanded address of created object as an |n| argument.
%  \end{itemize}
%
%  Initializer will be executed in the same order they're added.
%
%  \fromV{2.3}
% \end{function}
%
% \section{Examples}
%  \subsection*{Example 1}
% Create a public proxy with id \verb|myproxy| with the specification of a single member variable with name \verb|myvar| and type \verb|tl|, then set its address inside \cs{g_myproxy_str}.
%
% \begin{Coding}
% !simfun[str_new][N] !simvar[g_myproxy_str]
% !simfun[proxy_create_gset][Nnn] !simvar[g_myproxy_str] { example }{ myproxy }
% !simfun[proxy_push_member][Vnn] !simvar[g_myproxy_str] { myvar }{ tl }
% \end{Coding}
%
% Then create a new object with name \verb|myobj| with that proxy, assign then token list \verb|\c_dollar_str{} ~ dollar ~ \c_dollar_str{}| to \verb|myvar| and then print it.
%
% \begin{Coding}
% !simfun[str_new][N] !simvar[g_myobj_str]
% !simfun[rwobj_create_gset][NVnn] !simvar[g_myobj_str] !simvar[g_myproxy_str]
%   { example }{ myobj }
% !simfun[tl_gset][cn]
%   {
%     !simfun[rwobj_member_adr][Vn] !simvar[g_myobj_str] { myvar }
%   }
%   { !simvar[c_dollar_str]{} ~ dollar ~ !simvar[c_dollar_str]{} }
% !simfun[object_member_use][Vn] !simvar[g_myobj_str] { myvar }
% \end{Coding}
%
% Output: \ExplSyntaxOn
% \str_new:N \g_myproxy_str
% \proxy_create_gset:Nnn \g_myproxy_str { example }{ myproxy }
% \proxy_push_member:Vnn \g_myproxy_str { myvar }{ tl }
% \str_new:N \g_myobj_str
% \object_create_gset:NVnn \g_myobj_str \g_myproxy_str
%   { example }{ myobj }
% \tl_gset:cn
%   {
%     \object_member_adr:Vn \g_myobj_str { myvar }
%   }
%   { \c_dollar_str{} ~ dollar ~ \c_dollar_str{} }
% \object_member_use:Vn \g_myobj_str { myvar }
% \ExplSyntaxOff
%
% You can also avoid to specify an object identify and use \cs{object_gallocate_gincr} instead:
%
% \begin{Coding}
% !simfun[int_new][N] !simvar[g_intc_int]
% !simfun[object_gallocate_gincr][NNVnNN] !simvar[g_myobj_str] !simvar[g_intc_int] !simvar[g_myproxy_str]
%   { example } !simvar[c_object_local_str] !simvar[c_object_public_str]
% !simfun[tl_gset][cn]
%   {
%     !simfun[object_member_adr][Vn] !simvar[g_myobj_str] { myvar }
%   }
%   { !simvar[c_dollar_str]{} ~ dollar ~ !simvar[c_dollar_str]{} }
% !simfun[object_member_use][Vn] !simvar[g_myobj_str] { myvar }
% \end{Coding}
%
% Output: \ExplSyntaxOn
% \int_new:N \g_intc_int
% \object_gallocate_gincr:NNVnNN \g_myobj_str \g_intc_int \g_myproxy_str
%   { example } \c_object_local_str \c_object_public_str
% \tl_gset:cn
%   {
%     \object_member_adr:Vn \g_myobj_str { myvar }
%   }
%   { \c_dollar_str{} ~ dollar ~ \c_dollar_str{} }
% \object_member_use:Vn \g_myobj_str { myvar }
% \ExplSyntaxOff
%
% \subsection*{Example 2}
% In this example we create a proxy object with an embedded object inside.
%
% Internal proxy
% \begin{Coding}
%  !simfun[proxy_create][nn] { mymod }{ INT }
%  !simfun[proxy_push_member][nnn]
%    {
%      !simfun[object_address][nn] { mymod }{ INT }
%    }{ var }{ tl }
% \end{Coding}
%
% Container proxy
% \begin{Coding}
%  !simfun[proxy_create][nn] { mymod }{ EXT }
%  !simfun[proxy_push_embedded][nnn]
%    {
%      !simfun[object_address][nn] { mymod }{ EXT }
%    }
%    { emb }
%    {
%      !simfun[object_address][nn] { mymod }{ INT }
%    }
% \end{Coding}
%
% Now we create a new object from proxy |EXT|. It'll contain an embedded object created with |INT| proxy:
% \begin{Coding}
%  !simfun[str_new][N] !simvar[g_EXTobj_str]
%  !simfun[int_new][N] !simvar[g_intcount_int]
%  !simfun[object_gallocate_gincr][NNnnNN]
%    !simvar[g_EXTobj_str] !simvar[g_intcount_int]
%    {
%      !simfun[object_address][nn] { mymod }{ EXT }
%    }
%    { mymod }
%    !simvar[c_object_local_str] !simvar[c_object_public_str]
% \end{Coding}
% and use the embedded object in the following way:
% \begin{Coding}
%  !simfun[object_member_set][nnn]
%    {
%      !simfun[object_embedded_adr][Vn] !simvar[g_EXTobj_str] { emb }
%    }{ var }{ Hi }
%  !simfun[object_member_use][nn]
%    {
%      !simfun[object_embedded_adr][Vn] !simvar[g_EXTobj_str] { emb }
%    }{ var }
% \end{Coding}
% Output: \ExplSyntaxOn
%  \proxy_create:nn{ mymod }{ INT }
%  \proxy_push_member:nnn
%    {
%      \object_address:nn{ mymod }{ INT }
%    }{ var }{ tl }
%
%  \proxy_create:nn{ mymod }{ EXT }
%  \proxy_push_embedded:nnn
%    {
%      \object_address:nn{ mymod }{ EXT }
%    }
%    { emb }
%    {
%      \object_address:nn{ mymod }{ INT }
%    }
%
%  \str_new:N \g_EXTobj_str
%  \int_new:N \g_intcount_int
%  \object_gallocate_gincr:NNnnNN
%    \g_EXTobj_str \g_intcount_int
%    {
%      \object_address:nn{ mymod }{ EXT }
%    }
%    { mymod }
%    \c_object_local_str \c_object_public_str
%
%  \object_member_set:nnn
%    {
%      \object_embedded_adr:Vn \g_EXTobj_str { emb }
%    }{ var }{ Hi }
%  \object_member_use:nn
%    {
%      \object_embedded_adr:Vn \g_EXTobj_str { emb }
%    }{ var }
% \ExplSyntaxOff
%
% \subsection*{Example 3}
%  Here we show how to properly use \cs{object_member_generate:NN}. Suppose we don't know \cs{object_member_use} and we want to use \cs{tl_use:N} to get the value stored in member |MEM| of object |U| in module |MD3|.
%
% \ExplSyntaxOn
%    \proxy_create:nn {MD3}{ex3p}
%    \proxy_push_member:nnn { \object_address:nn {MD3}{ex3p} }{MEM}{tl}
%    \object_create:nnn { \object_address:nn {MD3}{ex3p} }{MD3}{U}
% \ExplSyntaxOff
%
% We can do it in this way:
% \begin{Coding}
% !simfun[tl_use][c]
%   {
%     !simfun[object_member_adr][nnn]
%       { !simfun[object_address][nn] { MD3 }{ U } }
%       { MEM }{ tl }
%   }
% \end{Coding}
% but this solution is not so pratical since we should write a lot of code each time. We can then use \cs{object_member_generate:NN} to define an auxilary macro \cs{myaux_print_tl:nnn} in this way:
% \begin{Coding}
% !simfun[object_member_generate][NN] \myaux_print_tl !simfun[tl_use][c]
% \end{Coding}
% then we can get the content of our member in this way:
% \begin{Coding}
% !simfun[myaux_print_tl][nnn]
%    { !simfun[object_address][nn] { MD3 }{ U } }
%    { MEM }{ tl }
% \end{Coding}
%
% For example if |U| contains |Hi| then the preceding code will output \ExplSyntaxOn
%  \object_member_set:nnnn
%    { \object_address:nn {MD3}{U}}{MEM}{tl}{Hi}
%  \object_member_generate_inline:Nnn \myaux_print_tl { #1_use }{ c }
%  \myaux_print_tl:nn
%    { \object_address:nn {MD3}{U}}{MEM}
%  \ExplSyntaxOff . If member |MEM| is tracked then you can use also the following command, which is generated together with \cs{myaux_print_tl:nnn}
% \begin{Coding}
% !simfun[myaux_print_tl][nn]
%    { !simfun[object_address][nn] { MD3 }{ U } }
%    { MEM }
% \end{Coding}
%
% However, this function only works with |tl| members since we use \cs{tl_use:N}, so you should define a new function for every possible type, and even if you do it newer types introduced in other packages will not be supported. In such cases you can use \cs{object_member_generate_inline:Nnn} which allows you to build the called function by specifying its name and its parameters. The preceding code then becomes
% \begin{Coding}
% !simfun[object_member_generate_inline][Nnn] \myaux_print_tl { tl_use }{ c }
% \end{Coding}
%
% This function does much more: in the second argument you can put also the parameters |#1| and |#2| that will expand respectively to the type of specified member and its scope. Let \cs{myaux_print:nnn} be our version of \cs{object_member_use:nnn} that retrieves the valued of the specified member, we are now able to define it in this way:
% \begin{Coding}
% !simfun[object_member_generate_inline][Nnn] \myaux_print { #1_use }{ c }
% \end{Coding}
%
% When you use \cs{myaux_print:nnn} on a member of type |int| it replaces all the recurrences of |#1| with |int|, thus it will call \cs{int_use:c}.
%\end{documentation}
%
%\begin{implementation}
%
%\section{Implementation}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=rawobjects>
%    \end{macrocode}
%
% Deprecation message
%    \begin{macrocode}

\msg_new:nnn { rawobjects }{ deprecate }
  {
    Command ~ #1 ~ is ~ deprecated. ~ Use ~ instead ~ #2
  }

\cs_new_protected:Nn \@@_launch_deprecate:NN
  {
    \msg_warning:nnnn{ rawobjects }{ deprecate }{ #1 }{ #2 }
  }

%    \end{macrocode}
%
% \begin{macro}{\rwobj_address_f:n}
% It just performs a |c| expansion before passing it to \cs{cs_to_str:N}.
%    \begin{macrocode}

\cs_new:Nn \rwobj_address_f:n
  {
    \exp_args:Nc \cs_to_str:N { #1 }
  }

%    \end{macrocode}
% \end{macro}
%
%\begin{variable}{\c_object_local_str, \c_object_global_str, \c_object_public_str, \c_object_private_str}
%    \begin{macrocode}
\str_const:Nn \c_object_local_str {l}
\str_const:Nn \c_object_global_str {g}

\cs_new:Nn \@@_scope_pfx:N
  {
    \str_if_eq:NNF #1 \c_object_local_str
      { g }
  }
  
\cs_generate_variant:Nn \@@_scope_pfx:N { c }

\cs_new:Nn \@@_scope_pfx_cl:n 
  {
    \@@_scope_pfx:c{
	  \object_ncmember_adr:nnn 
	    {
		  \object_embedded_adr:nn { #1  }{ /_I_/ }
		}
		{ S }{ str }
	}
  }

%    \end{macrocode}
%\end{variable}
%
%    \begin{macrocode}
\cs_new:Nn \object_address:nn {
  \tl_to_str:n { #1  .  #2 }
}
%    \end{macrocode}
%
%    \begin{macrocode}

\cs_new:Nn \object_embedded_adr:nn
  {
    #1 \tl_to_str:n{ . #2 }
  }
  
\cs_generate_variant:Nn \object_embedded_adr:nn{ Vn }

%    \end{macrocode}
%
%    \begin{macrocode}

\cs_new_protected:Nn \object_address_set:Nnn {
  \str_set:Nn #1 { #2  .  #3 }
}

\cs_new_protected:Nn \object_address_gset:Nnn {
  \str_gset:Nn #1 { #2  .  #3 }
}

%    \end{macrocode}
%
%\begin{macro}[pTF]{\rwobj_object_if_exist:n}
%Tests if object exists.
%    \begin{macrocode}

\prg_new_conditional:Nnn \rwobj_object_if_exist:n { p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_nconstant_adr:nnn
          {
            #1 . /_I_/
          }
          { S }{ str }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_generate_conditional_variant:Nnn \rwobj_object_if_exist:n { V }
  { p, T, F, TF }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\rwobj_object_get_module:n, \rwobj_object_get_proxy_adr:n}
%Retrieve the name, module and generating proxy of an object
%    \begin{macrocode}
\cs_new:Nn \rwobj_object_get_module:n {
  \rwobj_nconstant_use:nnn
  {
    #1 . /_I_/ 
  }
  { M }{ str }
}
\cs_new:Nn \rwobj_object_get_proxy_adr:n {
  \rwobj_nconstant_use:nnn
  {
     #1 . /_I_/ 
  }
  { P }{ str }
}

\cs_generate_variant:Nn \rwobj_object_get_module:n { V }
\cs_generate_variant:Nn \rwobj_object_get_proxy_adr:n { V }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[pTF]{\rwobj_object_if_local:n, \rwobj_object_if_global:n}
%Test the specified parameters.
%    \begin{macrocode}
\prg_new_conditional:Nnn \rwobj_object_if_local:n {p, T, F, TF}
{
  \str_if_eq:cNTF
    {
      \rwobj_nconstant_adr:nnn
        {
          #1 . /_I_/
        }
        { S }{ str }
    }
    \c_object_local_str
    {
      \prg_return_true:
    }
    {
      \prg_return_false:
    }
}

\prg_new_conditional:Nnn \rwobj_object_if_global:n {p, T, F, TF}
{
  \str_if_eq:cNTF
    {
      \rwobj_nconstant_adr:nnn
        {
          #1 . /_I_/
        }
        { S }{ str }
    }
    \c_object_global_str
    {
      \prg_return_true:
    }
    {
      \prg_return_false:
    }
}

\prg_generate_conditional_variant:Nnn \rwobj_object_if_local:n { V }
  { p, T, F, TF }
\prg_generate_conditional_variant:Nnn \rwobj_object_if_global:n { V }
  { p, T, F, TF }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\rwobj_macro_adr:nn, \rwobj_macro_use:nn}
% Generic macro address
%    \begin{macrocode}

\cs_new:Nn \rwobj_macro_adr:nn
  {
    #1 . MACRO_ \tl_to_str:n{ #2 }
  }
  
\cs_generate_variant:Nn \rwobj_macro_adr:nn{ Vn }

\cs_new:Nn \rwobj_macro_use:nn
  {
    \use:c
      {
        \rwobj_macro_adr:nn{ #1 }{ #2 }
      }
  }
  
\cs_generate_variant:Nn \rwobj_macro_use:nn{ Vn }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\rwobj_member_adr:nnn}
%Get the address of a member variable
%    \begin{macrocode}

\cs_new:Nn \rwobj_member_adr:nnn
  {
    \@@_member_adr:nnnc { #1 }{ #2 }{ #3 }
      {
        \object_nconstant_adr:nnn
          {
            #1 . /_I_/
          }
          { S }{ str }
      }
  }

\cs_generate_variant:Nn \object_member_adr:nnn { Vnn, vnn, nnv, nnf }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}[pTF]{\rwobj_member_if_exist:nnn}
% Tests if the specified member exists
%    \begin{macrocode}

\prg_new_conditional:Nnn \rwobj_member_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_member_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_generate_conditional_variant:Nnn \rwobj_member_if_exist:nnn
  { Vnn }{ p, T, F, TF }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\rwobj_member_if_tracked:nn}
% Tests if the member is tracked.
%    \begin{macrocode}

\prg_new_conditional:Nnn \rwobj_member_if_tracked:nn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_rconstant_adr:nnn
          { #1 }{ #2 _ type }{ str }
      }
      {
        \prg_return_true:
      }
      {
        \cs_if_exist:cTF
          {
            \object_nconstant_adr:nnn
              {
                #1./_T_/
              }
              { #2 _ type }{ str }
          }
          {
            \prg_return_true:
          }
          {
            \prg_return_false:
          }
      }
  }

\prg_generate_conditional_variant:Nnn \rwobj_member_if_tracked:nn
  { Vn }{ p, T, F, TF }

\prg_new_eq_conditional:NNn \rwobj_member_if_exist:nn
  \rwobj_member_if_tracked:nn { p, T, F, TF }
\prg_new_eq_conditional:NNn \rwobj_member_if_exist:Vn
  \rwobj_member_if_tracked:Vn { p, T, F, TF }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rwobj_member_type:nn}
% Deduce the type of tracked members.
%    \begin{macrocode}

\cs_new:Nn \rwobj_member_type:nn
  {
    \cs_if_exist:cTF
      {
        \rwobj_rconstant_adr:nnn
          { #1 }{ #2 _ type }{ str }
      }
      {
        \rwobj_rconstant_use:nnn
          { #1 }{ #2 _ type }{ str }
      }
      {
        \cs_if_exist:cT
          {
            \rwobj_nconstant_adr:nnn
              {
                #1./_T_/
              }
              { #2 _ type }{ str }
          }
          {
            \rwobj_nconstant_use:nnn
              {
                #1./_T_/ 
              }
              { #2 _ type }{ str }
          }
      }
  }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\rwobj_member_adr:nn}
%Get the address of a member variable
%    \begin{macrocode}

\cs_new:Nn \rwobj_member_adr:nn
  {
    \rwobj_member_adr:nnf { #1 }{ #2 }
      {
        \rwobj_member_type:nn { #1 }{ #2 }
      }
  }

\cs_generate_variant:Nn \rwobj_member_adr:nn { Vn }

%    \end{macrocode}
%\end{macro}
%
% Helper functions for \cs{object_*_generate} functions.
%    \begin{macrocode}

\cs_new:Nn \@@_par_trans:N
  {
    \str_case:nnF { #1 }
      {
        { N }{ N }
        { V }{ N }
        { n }{ n }
        { v }{ n }
        { f }{ n }
        { x }{ n }
        { e }{ n }
        { o }{ n }
        { ~ }{}
      }
      { #1 }
  }

\cs_new:Nn \@@_par_trans:n
  {
    \str_map_function:nN { #1 } \@@_par_trans:N
  }

\str_new:N \l_@@_tmp_fa_str

\cs_new_protected:Nn \@@_save_dat:n
  {
    \str_set:Nx \l_@@_tmp_fa_str
      { \str_tail:n{ #1 } }
  }
\cs_new_protected:Nn \@@_save_dat:nnN
  {
    \str_set:Nx \l_@@_tmp_fa_str
      { \str_tail:n{ #2 } }
  }
\cs_new_protected:Nn \@@_save_dat_aux:n
  {
    \@@_save_dat:nnN #1
  }
\cs_generate_variant:Nn \@@_save_dat_aux:n { f }

\cs_new_protected:Nn \@@_save_fun:N
  {
    \@@_save_dat_aux:f { \cs_split_function:N #1 }
  }
  
\cs_new:Nn \@@_use_dat:nn
  {
    #1 : #2 \str_use:N \l_@@_tmp_fa_str
  }

%    \end{macrocode}
%
% \begin{macro}{\rwobj_member_generate:NN, \rwobj_member_generate_inline:Nnn, \rwobj_member_generate_protected:NN, \rwobj_member_generate_protected_inline:Nnn}
% Generate member versions of specified functions.
%    \begin{macrocode}

\cs_new_protected:Nn \@@_mgen:nN
  {
    \@@_save_fun:N #2
    \cs_new:cpn { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        #2
          {
            \rwobj_member_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
    \cs_new:cpn { #1 : nn \str_use:N \l_@@_tmp_fa_str } ##1##2
      {
        #2
          {
            \rwobj_member_adr:nn{ ##1 }{ ##2 }
          }
      }
  }
\cs_new_protected:Nn \@@_mgen_pr:nN
  {
    \@@_save_fun:N #2
    \cs_new_protected:cpn
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        #2
          {
            \rwobj_member_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
    \cs_new_protected:cpn
      { #1 : nn \str_use:N \l_@@_tmp_fa_str } ##1##2
      {
        #2
          {
            \rwobj_member_adr:nn{ ##1 }{ ##2 }
          }
      }
  }

\cs_new_protected:Nn \@@_mgen:nnn
  {
    \@@_save_dat:n { #3 }

    \cs_new:cpn { @@_auxfun_#1 :nn } ##1##2
      {
        \use:c{ #2 : #3 }
      }
    \cs_generate_variant:cn { @@_auxfun_#1 :nn }{ nf, ff }

    \cs_new:cpn { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        \use:c { @@_auxfun_#1 :nf }
          { ##3 }
          {
            \@@_scope_pfx_cl:n{ ##1 }
          }
          {
            \rwobj_member_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
    \cs_new:cpn { #1 : nn \str_use:N \l_@@_tmp_fa_str } ##1##2
      {
        \use:c { @@_auxfun_#1 :ff }
          {
            \rwobj_member_type:nn { ##1 }{ ##2 }
          }
          {
            \@@_scope_pfx_cl:n{ ##1 }
          }
          {
            \rwobj_member_adr:nn{ ##1 }{ ##2 }
          }
      }
  }
\cs_new_protected:Nn \@@_mgen_pr:nnn
  {
    \@@_save_dat:n { #3 }

    \cs_new:cpn { @@_auxfun_#1 :nn } ##1##2
      {
        \use:c{ #2 : #3 }
      }
    \cs_generate_variant:cn { @@_auxfun_#1 :nn }{ nf, ff }

    \cs_new_protected:cpn
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        \use:c { @@_auxfun_#1 :nf }
          { ##3 }
          {
            \@@_scope_pfx_cl:n{ ##1 }
          }
          {
            \rwobj_member_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
    \cs_new_protected:cpn
      { #1 : nn \str_use:N \l_@@_tmp_fa_str } ##1##2
      {
        \use:c { @@_auxfun_#1 :ff }
          {
            \rwobj_member_type:nn { ##1 }{ ##2 }
          }
          {
            \@@_scope_pfx_cl:n{ ##1 }
          }
          {
            \rwobj_member_adr:nn{ ##1 }{ ##2 }
          }
      }
  }

\cs_generate_variant:Nn \@@_mgen:nN { fN }
\cs_generate_variant:Nn \@@_mgen:nnn { fnn }
\cs_generate_variant:Nn \@@_mgen_pr:nN { fN }
\cs_generate_variant:Nn \@@_mgen_pr:nnn { fnn }

\cs_new_protected:Nn \rwobj_member_generate:NN
  {
    \@@_mgen:fN { \cs_to_str:N #1 } #2
  }

\cs_new_protected:Nn \rwobj_member_generate_inline:Nnn
  {
    \@@_mgen:fnn { \cs_to_str:N #1 }{ #2 }{ #3 }
  }
\cs_new_protected:Nn \rwobj_member_generate_protected:NN
  {
    \@@_mgen_pr:fN { \cs_to_str:N #1 } #2
  }

\cs_new_protected:Nn \rwobj_member_generate_protected_inline:Nnn
  {
    \@@_mgen_pr:fnn { \cs_to_str:N #1 }{ #2 }{ #3 }
  }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rwobj_ncmember_generate:NN, \rwobj_ncmember_generate_inline:Nnn, \rwobj_ncmember_generate_protected:NN, \rwobj_ncmember_generate_protected_inline:Nnn}
% Generate ncmember versions of specified functions.
%    \begin{macrocode}

\cs_new_protected:Nn \@@_ncgen:nN
  {
    \@@_save_fun:N #2
    \cs_new:cpn { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        #2
          {
            \rwobj_ncmember_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
  }
\cs_new_protected:Nn \@@_ncgen_pr:nN
  {
    \@@_save_fun:N #2
    \cs_new_protected:cpn
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        #2
          {
            \rwobj_ncmember_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
  }

\cs_new_protected:Nn \@@_ncgen:nnn
  {
    \@@_save_dat:n { #3 }

    \cs_new:cpn { @@_auxfun_#1 :nn } ##1##2
      {
        \use:c{ #2 : #3 }
      }
    \cs_generate_variant:cn { @@_auxfun_#1 :nn }{ nf }

    \cs_new:cpn { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        \use:c { @@_auxfun_#1 :nf }
          { ##3 }
          {
            \@@_scope_pfx_cl:n{ ##1 }
          }
          {
            \rwobj_ncmember_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
  }
\cs_new_protected:Nn \@@_ncgen_pr:nnn
  {
    \@@_save_dat:n { #3 }

    \cs_new:cpn { @@_auxfun_#1 :nn } ##1##2
      {
        \use:c{ #2 : #3 }
      }
    \cs_generate_variant:cn { @@_auxfun_#1 :nn }{ nf }

    \cs_new_protected:cpn
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        \use:c { @@_auxfun_#1 :nf }
          { ##3 }
          {
            \@@_scope_pfx_cl:n{ ##1 }
          }
          {
            \rwobj_ncmember_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
  }

\cs_generate_variant:Nn \@@_ncgen:nN { fN }
\cs_generate_variant:Nn \@@_ncgen:nnn { fnn }
\cs_generate_variant:Nn \@@_ncgen_pr:nN { fN }
\cs_generate_variant:Nn \@@_ncgen_pr:nnn { fnn }

\cs_new_protected:Nn \rwobj_ncmember_generate:NN
  {
    \@@_ncgen:fN { \cs_to_str:N #1 } #2
  }

\cs_new_protected:Nn \rwobj_ncmember_generate_inline:Nnn
  {
    \@@_ncgen:fnn { \cs_to_str:N #1 }{ #2 }{ #3 }
  }
\cs_new_protected:Nn \rwobj_ncmember_generate_protected:NN
  {
    \@@_ncgen_pr:fN { \cs_to_str:N #1 } #2
  }

\cs_new_protected:Nn \rwobj_ncmember_generate_protected_inline:Nnn
  {
    \@@_ncgen_pr:fnn { \cs_to_str:N #1 }{ #2 }{ #3 }
  }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rwobj_rcmember_generate:NN, \rwobj_rcmember_generate_inline:Nnn, \rwobj_rcmember_generate_protected:NN, \rwobj_rcmember_generate_protected_inline:Nnn}
% Generate ncmember versions of specified functions.
%    \begin{macrocode}

\cs_new_protected:Nn \@@_rcgen:nN
  {
    \@@_save_fun:N #2
    \cs_new:cpn { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        #2
          {
            \rwobj_rcmember_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
  }
\cs_new_protected:Nn \@@_rcgen_pr:nN
  {
    \@@_save_fun:N #2
    \cs_new_protected:cpn
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        #2
          {
            \rwobj_rcmember_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
  }

\cs_new_protected:Nn \@@_rcgen:nnn
  {
    \@@_save_dat:n { #3 }

    \cs_new:cpn { @@_auxfun_#1 :nn } ##1##2
      {
        \use:c{ #2 : #3 }
      }
    \cs_generate_variant:cn { @@_auxfun_#1 :nn }{ nf }

    \cs_new:cpn { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        \use:c { @@_auxfun_#1 :nf }
          { ##3 }
          {
            \@@_scope_pfx_cl:n{ ##1 }
          }
          {
            \rwobj_rcmember_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
  }
\cs_new_protected:Nn \@@_rcgen_pr:nnn
  {
    \@@_save_dat:n { #3 }

    \cs_new:cpn { @@_auxfun_#1 :nn } ##1##2
      {
        \use:c{ #2 : #3 }
      }
    \cs_generate_variant:cn { @@_auxfun_#1 :nn }{ nf }

    \cs_new_protected:cpn
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str } ##1##2##3
      {
        \use:c { @@_auxfun_#1 :nf }
          { ##3 }
          {
            \@@_scope_pfx_cl:n{ ##1 }
          }
          {
            \rwobj_rcmember_adr:nnn{ ##1 }{ ##2 }{ ##3 }
          }
      }
  }

\cs_generate_variant:Nn \@@_rcgen:nN { fN }
\cs_generate_variant:Nn \@@_rcgen:nnn { fnn }
\cs_generate_variant:Nn \@@_rcgen_pr:nN { fN }
\cs_generate_variant:Nn \@@_rcgen_pr:nnn { fnn }

\cs_new_protected:Nn \rwobj_rcmember_generate:NN
  {
    \@@_rcgen:fN { \cs_to_str:N #1 } #2
  }

\cs_new_protected:Nn \rwobj_rcmember_generate_inline:Nnn
  {
    \@@_rcgen:fnn { \cs_to_str:N #1 }{ #2 }{ #3 }
  }
\cs_new_protected:Nn \rwobj_rcmember_generate_protected:NN
  {
    \@@_rcgen_pr:fN { \cs_to_str:N #1 } #2
  }

\cs_new_protected:Nn \rwobj_rcmember_generate_protected_inline:Nnn
  {
    \@@_rcgen_pr:fnn { \cs_to_str:N #1 }{ #2 }{ #3 }
  }

%    \end{macrocode}
% \end{macro}
%
% Auxilary functions
%    \begin{macrocode}

\cs_generate_variant:Nn \cs_generate_variant:Nn { cx }

\cs_new_protected:Nn \@@_genmem_int:nnn
  {
    \@@_mgen:nnn { #1 }{ #2 }{ #3 }
    \cs_generate_variant:cx
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str }
      { Vnn \str_use:N \l_@@_tmp_fa_str, nnv \str_use:N \l_@@_tmp_fa_str }
    \cs_generate_variant:cx
      { #1 : nn \str_use:N \l_@@_tmp_fa_str }
      { Vn \str_use:N \l_@@_tmp_fa_str }
  }
\cs_new_protected:Nn \@@_genmem_pr_int:nnn
  {
    \@@_mgen_pr:nnn { #1 }{ #2 }{ #3 }
    \cs_generate_variant:cx
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str }
      { Vnn \str_use:N \l_@@_tmp_fa_str, nnv \str_use:N \l_@@_tmp_fa_str }
    \cs_generate_variant:cx
      { #1 : nn \str_use:N \l_@@_tmp_fa_str }
      { Vn \str_use:N \l_@@_tmp_fa_str }
  }

\cs_new_protected:Nn \@@_genncm_int:nnn
  {
    \@@_ncgen:nnn { #1 }{ #2 }{ #3 }
    \cs_generate_variant:cx
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str }
      { Vnn \str_use:N \l_@@_tmp_fa_str }
  }
\cs_new_protected:Nn \@@_genncm_pr_int:nnn
  {
    \@@_ncgen_pr:nnn { #1 }{ #2 }{ #3 }
    \cs_generate_variant:cx
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str }
      { Vnn \str_use:N \l_@@_tmp_fa_str }
  }

\cs_new_protected:Nn \@@_genrcm_int:nnn
  {
    \@@_rcgen:nnn { #1 }{ #2 }{ #3 }
    \cs_generate_variant:cx
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str }
      { Vnn \str_use:N \l_@@_tmp_fa_str }
  }
\cs_new_protected:Nn \@@_genrcm_pr_int:nnn
  {
    \@@_rcgen_pr:nnn { #1 }{ #2 }{ #3 }
    \cs_generate_variant:cx
      { #1 : nnn \str_use:N \l_@@_tmp_fa_str }
      { Vnn \str_use:N \l_@@_tmp_fa_str }
  }

%    \end{macrocode}
%
%    \begin{macrocode}

\msg_new:nnnn { rawobjects }{ noerr }{ Unspecified ~ scope }
  {
    Object ~ #1 ~ hasn't ~ a ~ scope ~ variable
  }

%    \end{macrocode}
%
%\begin{macro}{\rwobj_new_member:nnn, \rwobj_new_member_tracked:nnn}
%Creates a new member variable
%    \begin{macrocode}

\@@_genmem_pr_int:nnn { object_new_member }{ #1 _ new }{ c }

\cs_new_protected:Nn \rwobj_new_member_tracked:nnn
  {
    \rwobj_new_member:nnn { #1 }{ #2 }{ #3 }

    \str_const:cn
      {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn { #1 }{ /_T_/ }
          }
          { #2 _ type }{ str }
      }
      { #3 }
  }

\cs_generate_variant:Nn \rwobj_new_member_tracked:nnn { Vnn, nnv }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\rwobj_member_use:nnn, \rwobj_member_use:nn}
%Uses a member variable
%    \begin{macrocode}

\@@_genmem_int:nnn {object_member_use}{ #1_use }{c}

\cs_generate_variant:Nn \rwobj_member_use:nnn {vnn}

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\rwobj_member_set:nnnn, \rwobj_member_set:nnn}
% Set the value a member.
%    \begin{macrocode}

\@@_genmem_pr_int:nnn {object_member_set}{ #1_#2 set }{ cn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\rwobj_member_set_eq:nnnN, \rwobj_member_set_eq:nnN}
% Make a member equal to another variable.
%    \begin{macrocode}

\@@_genmem_pr_int:nnn { object_member_set_eq }{ #1 _ #2 set_eq }{ cN }

\cs_generate_variant:Nn \rwobj_member_set_eq:nnnN { nnnc, Vnnc }

\cs_generate_variant:Nn \rwobj_member_set_eq:nnN { nnc, Vnc }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\rwobj_ncmember_adr:nnn}
% Get address of near constant
%    \begin{macrocode}

\cs_new:Nn \rwobj_ncmember_adr:nnn
  {
    \tl_to_str:n{ c _ } #1 \tl_to_str:n { _ CONST _ #2 _ #3 }
  }

\cs_generate_variant:Nn \rwobj_ncmember_adr:nnn { Vnn, vnn }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\rwobj_rcmember_adr:nnn}
% Get the address of a remote constant.
%    \begin{macrocode}

\cs_new:Nn \rwobj_rcmember_adr:nnn
  {
    \rwobj_ncmember_adr:vnn
      {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { P }{ str }
      }
      { #2 }{ #3 }
  }

\cs_generate_variant:Nn \rwobj_rcmember_adr:nnn { Vnn }
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}[pTF]{\rwobj_ncmember_if_exist:nnn, \rwobj_rcmember_if_exist:nnn}
% Tests if the specified member constant exists.
%    \begin{macrocode}

\prg_new_conditional:Nnn \rwobj_ncmember_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \rwobj_ncmember_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_new_conditional:Nnn \rwobj_rcmember_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \rwobj_rcmember_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_generate_conditional_variant:Nnn \rwobj_ncmember_if_exist:nnn
  { Vnn }{ p, T, F, TF }
\prg_generate_conditional_variant:Nnn \rwobj_rcmember_if_exist:nnn
  { Vnn }{ p, T, F, TF }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\rwobj_ncmember_use:nnn, \rwobj_rcmember_use:nnn}
% Uses a near/remote constant.
%    \begin{macrocode}

\@@_genncm_int:nnn { object_ncmember_use }{ #1_use}{ c }

\@@_genrcm_int:nnn { object_rcmember_use }{ #1_use}{ c }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\rwobj_newconst:nnnn}
% Creates a constant variable, use with caution
%    \begin{macrocode}

\@@_genncm_pr_int:nnn { object_newconst }{ #1 _ const }{ cn }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rwobj_newconst_tl:nnn, \rwobj_newconst_str:nnn, \rwobj_newconst_int:nnn, \rwobj_newconst_clist:nnn, \rwobj_newconst_dim:nnn, \rwobj_newconst_skip:nnn, \rwobj_newconst_fp:nnn}
% Create constants
%    \begin{macrocode}

\cs_new_protected:Nn \rwobj_newconst_tl:nnn
  {
    \rwobj_newconst:nnnn { #1 }{ #2 }{ tl }{ #3 }
  }
\cs_new_protected:Nn \rwobj_newconst_str:nnn
  {
    \rwobj_newconst:nnnn { #1 }{ #2 }{ str }{ #3 }
  }
\cs_new_protected:Nn \rwobj_newconst_int:nnn
  {
    \rwobj_newconst:nnnn { #1 }{ #2 }{ int }{ #3 }
  }
\cs_new_protected:Nn \rwobj_newconst_clist:nnn
  {
    \rwobj_newconst:nnnn { #1 }{ #2 }{ clist }{ #3 }
  }
\cs_new_protected:Nn \rwobj_newconst_dim:nnn
  {
    \rwobj_newconst:nnnn { #1 }{ #2 }{ dim }{ #3 }
  }
\cs_new_protected:Nn \rwobj_newconst_skip:nnn
  {
    \rwobj_newconst:nnnn { #1 }{ #2 }{ skip }{ #3 }
  }
\cs_new_protected:Nn \rwobj_newconst_fp:nnn
  {
    \rwobj_newconst:nnnn { #1 }{ #2 }{ fp }{ #3 }
  }

\cs_generate_variant:Nn \rwobj_newconst_tl:nnn { Vnn }
\cs_generate_variant:Nn \rwobj_newconst_str:nnn { Vnn }
\cs_generate_variant:Nn \rwobj_newconst_int:nnn { Vnn }
\cs_generate_variant:Nn \rwobj_newconst_clist:nnn { Vnn }
\cs_generate_variant:Nn \rwobj_newconst_dim:nnn { Vnn }
\cs_generate_variant:Nn \rwobj_newconst_skip:nnn { Vnn }
\cs_generate_variant:Nn \rwobj_newconst_fp:nnn { Vnn }


\cs_generate_variant:Nn \rwobj_newconst_str:nnn { nnx }
\cs_generate_variant:Nn \rwobj_newconst_str:nnn { nnV }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\rwobj_newconst_seq_from_clist:nnn}
%  Creates a |seq| constant.
%    \begin{macrocode}

\cs_new_protected:Nn \rwobj_newconst_seq_from_clist:nnn
  {
    \seq_const_from_clist:cn
      {
        \rwobj_ncmember_adr:nnn { #1 }{ #2 }{ seq }
      }
      { #3 }
  }

\cs_generate_variant:Nn \rwobj_newconst_seq_from_clist:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\rwobj_newconst_prop_from_keyval:nnn}
%  Creates a |prop| constant.
%    \begin{macrocode}

\cs_new_protected:Nn \rwobj_newconst_prop_from_keyval:nnn
  {
    \prop_const_from_keyval:cn
      {
        \rwobj_ncmember_adr:nnn { #1 }{ #2 }{ prop }
      }
      { #3 }
  }

\cs_generate_variant:Nn \rwobj_newconst_prop_from_keyval:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
%
% \begin{macro}{\rwobj_ncmethod_adr:nnn, \rwobj_rcmethod_adr:nnn}
% Fully expands to the method address.
%    \begin{macrocode}

\cs_new:Nn \rwobj_ncmethod_adr:nnn
  {
    #1 \tl_to_str:n { _ CMETHOD _ #2 : #3 }
  }

\cs_generate_variant:Nn \rwobj_ncmethod_adr:nnn { Vnn , vnn }

\cs_new:Nn \rwobj_rcmethod_adr:nnn
  {
    \rwobj_ncmethod_adr:vnn
      {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { P }{ str }
      }
      { #2 }{ #3 }
  }

\cs_generate_variant:Nn \rwobj_ncmethod_adr:nnn { Vnn , vnn }
\cs_generate_variant:Nn \rwobj_rcmethod_adr:nnn { Vnn }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\rwobj_ncmethod_if_exist:nnn, \rwobj_rcmethod_if_exist:nnn}
% Tests if the specified member constant exists.
%    \begin{macrocode}

\prg_new_conditional:Nnn \rwobj_ncmethod_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \rwobj_ncmethod_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_new_conditional:Nnn \rwobj_rcmethod_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \rwobj_rcmethodr_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_generate_conditional_variant:Nnn \rwobj_ncmethod_if_exist:nnn
  { Vnn }{ p, T, F, TF }
\prg_generate_conditional_variant:Nnn \rwobj_rcmethod_if_exist:nnn
  { Vnn }{ p, T, F, TF }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rwobj_new_cmethod:nnnn}
% Creates a new method
%    \begin{macrocode}

\cs_new_protected:Nn \rwobj_new_cmethod:nnnn
  {
    \cs_new:cn
	  {
	    \rwobj_ncmethod_adr:nnn { #1 }{ #2 }{ #3 }
	  }
	  { #4 }
  }
  
\cs_generate_variant:Nn \rwobj_new_cmethod:nnnn { Vnnn }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rwobj_ncmethod_call:nnn, \rwobj_rcmethod_call:nnn}
% Calls the specified method.
%    \begin{macrocode}

\cs_new:Nn \rwobj_ncmethod_call:nnn
  {
    \use:c
	  {
	    \rwobj_ncmethod_adr:nnn { #1 }{ #2 }{ #3 }
	  }
  }

\cs_new:Nn \rwobj_rcmethod_call:nnn
  {
    \use:c
	  {
	    \rwobj_rcmethod_adr:nnn { #1 }{ #2 }{ #3 }
	  }
  }
  
\cs_generate_variant:Nn \rwobj_ncmethod_call:nnn { Vnn }
\cs_generate_variant:Nn \rwobj_rcmethod_call:nnn { Vnn }

%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}

\cs_new_protected:Nn \@@_initproxy:nnn
  {
    \rwobj_newconst:nnnn
      {
        \rwobj_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { ifprox }{ bool }{ \c_true_bool }
  }
\cs_generate_variant:Nn \@@_initproxy:nnn { VnV }

%    \end{macrocode}
%
%
%\begin{macro}[pTF]{\rwobj_if_proxy:n}
%Test if an object is a proxy.
%    \begin{macrocode}

\cs_new:Nn \@@_bol_com:N
  {
    \cs_if_exist_p:N #1 && \bool_if_p:N #1
  }

\cs_generate_variant:Nn \@@_bol_com:N { c }

\prg_new_conditional:Nnn \rwobj_if_proxy:n {p, T, F, TF}
  {
    \cs_if_exist:cTF
      {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { ifprox }{ bool }
      }
      {
        \bool_if:cTF
          {
            \rwobj_ncmember_adr:nnn
              {
                \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
              }
              { ifprox }{ bool }
          }
          {
            \prg_return_true:
          }
          {
            \prg_return_false:
          }
      }
      {
        \prg_return_false:
      }
  }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[pTF]{\rwobj_test_proxy:nn, \rwobj_test_proxy:nN}
%Test if an object is generated from selected proxy.
%    \begin{macrocode}

\prg_generate_conditional_variant:Nnn \str_if_eq:nn { ve }{ TF }

\prg_new_conditional:Nnn \rwobj_test_proxy:nn {p, T, F, TF}
  {
    \str_if_eq:veTF
      {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { P }{ str }
      }
	  { #2 }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_new_conditional:Nnn \rwobj_test_proxy:nN {p, T, F, TF}
  {
    \str_if_eq:cNTF
      {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { P }{ str }
      }
	  #2
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }
  
\prg_generate_conditional_variant:Nnn \rwobj_test_proxy:nn
  { Vn }{p, T, F, TF}
\prg_generate_conditional_variant:Nnn \rwobj_test_proxy:nN
  { VN }{p, T, F, TF}

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\rwobj_create:nnnNN, \rwobj_create_set:NnnnNN, \rwobj_create_gset:NnnnNN, \rwobj_create:nnnN, \rwobj_create_set:NnnnN, \rwobj_create_gset:NnnnN, \rwobj_create:nnn, \rwobj_create_set:Nnnn, \rwobj_create_gset:Nnnn, \embedded_create:nnn}
% Creates an object from a proxy.
%    \begin{macrocode}

\msg_new:nnnn { rawobjects }{ notproxy }{ Fake ~ proxy }
  {
    Object ~ #1 ~ is ~ not ~ a ~ proxy.
  }

\cs_new_protected:Nn \@@_force_proxy:n
  {
    \rwobj_if_proxy:nF { #1 }
      {
        \msg_error:nnn { rawobjects }{ notproxy }{ #1 }
      }
  }

\cs_new_protected:Nn \@@_create_anon:nnnNN
  {
    \tl_if_empty:nF{ #1 }
    {

    \@@_force_proxy:n { #1 }
	
	
    \rwobj_newconst_str:nnn
      {
        \rwobj_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { M }{ #2 }
    \rwobj_newconst_str:nnn
      {
        \rwobj_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { P }{ #1 }
    \rwobj_newconst_str:nnV
      {
        \rwobj_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { S } #4
    \rwobj_newconst_str:nnV
      {
        \rwobj_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { V } #5

    \seq_map_inline:cn
      {
        \rwobj_member_adr:nnn { #1 }{ varlist }{ seq }
      }
      {
        \rwobj_new_member:nnv { #3 }{ ##1 }
          {
            \rwobj_ncmember_adr:nnn { #1 }{ ##1 _ type }{ str }
          }
      }
      
    \seq_map_inline:cn
      {
        \rwobj_member_adr:nnn { #1 }{ objlist }{ seq }
      }
      {
        \embedded_create:nvn
          { #3 }
          {
            \rwobj_ncmember_adr:nnn { #1 }{ ##1 _ proxy }{ str }
          }
          { ##1 }
      }

    \tl_map_inline:cn
      {
        \rwobj_member_adr:nnn { #1 }{ init }{ tl }
      }
      {
        ##1 { #1 }{ #2 }{ #3 }
      }

    }
  }
  
\cs_generate_variant:Nn \@@_create_anon:nnnNN { xnxNN, xvxcc }

\cs_new_protected:Nn \rwobj_create:nnnNN
  {
    \@@_create_anon:xnxNN { #1 }{ #2 }
      { \rwobj_address:nn { #2 }{ #3 } }
      #4 #5
  }

\cs_generate_variant:Nn \rwobj_create:nnnNN { VnnNN }

\cs_new_protected:Nn \rwobj_create_set:NnnnNN
  {
    \rwobj_create:nnnNN { #2 }{ #3 }{ #4 } #5 #6
    \str_set:Nx #1 { \rwobj_address:nn { #3 }{ #4 } }
  }

\cs_new_protected:Nn \rwobj_create_gset:NnnnNN
  {
    \rwobj_create:nnnNN { #2 }{ #3 }{ #4 } #5 #6
    \str_gset:Nx #1 { \rwobj_address:nn { #3 }{ #4 } }
  }

\cs_generate_variant:Nn \rwobj_create_set:NnnnNN { NVnnNN, NnnfNN }
\cs_generate_variant:Nn \rwobj_create_gset:NnnnNN { NVnnNN, NnnfNN }



\cs_new_protected:Nn \rwobj_create:nnnN
  {
    \rwobj_create:nnnNN { #1 }{ #2 }{ #3 } #4 \c_object_public_str
  }

\cs_generate_variant:Nn \rwobj_create:nnnN { VnnN }

\cs_new_protected:Nn \rwobj_create_set:NnnnN
  {
    \rwobj_create_set:NnnnNN #1 { #2 }{ #3 }{ #4 } #5 \c_object_public_str
  }

\cs_new_protected:Nn \rwobj_create_gset:NnnnN
  {
    \rwobj_create_gset:NnnnNN #1 { #2 }{ #3 }{ #4 } #5 \c_object_public_str
  }

\cs_generate_variant:Nn \rwobj_create_set:NnnnN { NVnnN }
\cs_generate_variant:Nn \rwobj_create_gset:NnnnN { NVnnN }

\cs_new_protected:Nn \rwobj_create:nnn
  {
    \rwobj_create:nnnNN { #1 }{ #2 }{ #3 }
      \c_object_global_str \c_object_public_str
  }

\cs_generate_variant:Nn \rwobj_create:nnn { Vnn }

\cs_new_protected:Nn \rwobj_create_set:Nnnn
  {
    \rwobj_create_set:NnnnNN #1 { #2 }{ #3 }{ #4 }
      \c_object_global_str \c_object_public_str
  }

\cs_new_protected:Nn \rwobj_create_gset:Nnnn
  {
    \rwobj_create_gset:NnnnNN #1 { #2 }{ #3 }{ #4 }
      \c_object_global_str \c_object_public_str
  }

\cs_generate_variant:Nn \rwobj_create_set:Nnnn { NVnn }
\cs_generate_variant:Nn \rwobj_create_gset:Nnnn { NVnn }



  
\cs_new_protected:Nn \embedded_create:nnn
  {
    \@@_create_anon:xvxcc { #2 }
	  {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { M }{ str }
      }
      {
        \rwobj_embedded_adr:nn
          { #1 }{ #3 }
      }
      {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { S }{ str }
      }
      {
        \rwobj_ncmember_adr:nnn
          {
            \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { V }{ str }
      }
  }

\cs_generate_variant:Nn \embedded_create:nnn { nvn, Vnn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\proxy_create:nn, \proxy_create_set:Nnn, \proxy_create_gset:Nnn}
%Creates a new proxy object
%    \begin{macrocode}

\cs_new_protected:Nn \proxy_create:nn
  {
    \rwobj_create:VnnNN \c_proxy_address_str { #1 }{ #2 }
      \c_object_global_str \c_object_public_str
  }

\cs_new_protected:Nn \proxy_create_set:Nnn
  {
    \rwobj_create_set:NVnnNN #1 \c_proxy_address_str { #2 }{ #3 }
      \c_object_global_str \c_object_public_str
  }

\cs_new_protected:Nn \proxy_create_gset:Nnn
  {
    \rwobj_create_gset:NVnnNN #1 \c_proxy_address_str { #2 }{ #3 }
      \c_object_global_str \c_object_public_str
  }



\cs_new_protected:Nn \proxy_create:nnN
  {
    \@@_launch_deprecate:NN \proxy_create:nnN \proxy_create:nn
    \rwobj_create:VnnNN \c_proxy_address_str { #1 }{ #2 }
      \c_object_global_str #3
  }

\cs_new_protected:Nn \proxy_create_set:NnnN
  {
    \@@_launch_deprecate:NN \proxy_create_set:NnnN \proxy_create_set:Nnn
    \rwobj_create_set:NVnnNN #1 \c_proxy_address_str { #2 }{ #3 }
      \c_object_global_str #4
  }

\cs_new_protected:Nn \proxy_create_gset:NnnN
  {
    \@@_launch_deprecate:NN \proxy_create_gset:NnnN \proxy_create_gset:Nnn
    \rwobj_create_gset:NVnnNN #1 \c_proxy_address_str { #2 }{ #3 }
      \c_object_global_str #4
  }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\proxy_push_member:nnn}
% Push a new member inside a proxy.
%    \begin{macrocode}

\cs_new_protected:Nn \proxy_push_member:nnn
  {
    \rwobj_newconst_str:nnn { #1 }{ #2 _ type }{ #3 }
    \seq_gput_left:cn
      {
        \rwobj_member_adr:nnn { #1 }{ varlist }{ seq }
      }
      { #2 }
  }

\cs_generate_variant:Nn \proxy_push_member:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\proxy_push_embedded:nnn}
% Push a new embedded object inside a proxy.
%    \begin{macrocode}

\cs_new_protected:Nn \proxy_push_embedded:nnn
  {
    \rwobj_newconst_str:nnx { #1 }{ #2 _ proxy }{ #3 }
    \seq_gput_left:cn
      {
        \rwobj_member_adr:nnn { #1 }{ objlist }{ seq }
      }
      { #2 }
  }

\cs_generate_variant:Nn \proxy_push_embedded:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\proxy_add_initializer:nN}
% Push a new embedded object inside a proxy.
%    \begin{macrocode}

\cs_new_protected:Nn \proxy_add_initializer:nN
  {
    \tl_gput_right:cn
      {
        \rwobj_member_adr:nnn { #1 }{ init }{ tl }
      }
      { #2 }
  }

\cs_generate_variant:Nn \proxy_add_initializer:nN { VN }

%    \end{macrocode}
%\end{macro}
%
%\begin{variable}{\c_proxy_address_str}
% Variable containing the address of the \verb|proxy| object.
%    \begin{macrocode}

\str_const:Nx \c_proxy_address_str
  { \rwobj_address:nn { rawobjects }{ proxy } }
  
\rwobj_newconst_str:nnn
  {
    \rwobj_embedded_adr:Vn \c_proxy_address_str { /_I_/ }
  }
  { M }{ rawobjects }

\rwobj_newconst_str:nnV
  {
    \rwobj_embedded_adr:Vn \c_proxy_address_str { /_I_/ }
  }
  { P } \c_proxy_address_str
  
\rwobj_newconst_str:nnV
  {
    \rwobj_embedded_adr:Vn \c_proxy_address_str { /_I_/ }
  }
  { S } \c_object_global_str

\rwobj_newconst_str:nnV
  {
    \rwobj_embedded_adr:Vn \c_proxy_address_str { /_I_/ }
  }
  { V } \c_object_public_str


\@@_initproxy:VnV \c_proxy_address_str { rawobjects } \c_proxy_address_str

\rwobj_new_member:Vnn \c_proxy_address_str { init }{ tl }

\rwobj_new_member:Vnn \c_proxy_address_str { varlist }{ seq }

\rwobj_new_member:Vnn \c_proxy_address_str { objlist }{ seq }

\proxy_push_member:Vnn \c_proxy_address_str
  { init }{ tl }
\proxy_push_member:Vnn \c_proxy_address_str
  { varlist }{ seq }
\proxy_push_member:Vnn \c_proxy_address_str
  { objlist }{ seq }

\proxy_add_initializer:VN \c_proxy_address_str
  \@@_initproxy:nnn

%    \end{macrocode}
%\end{variable}
%
% \begin{macro}{\rwobj_allocate_incr:NNnnNN, \rwobj_gallocate_incr:NNnnNN, \rwobj_allocate_gincr:NNnnNN, \rwobj_gallocate_gincr:NNnnNN}
% Create an address and use it to instantiate an object
%    \begin{macrocode}

\cs_new:Nn \@@_combine_aux:nnn
  {
    anon . #3 . #2 . #1
  }

\cs_generate_variant:Nn \@@_combine_aux:nnn { Vnf }

\cs_new:Nn \@@_combine:Nn
  {
    \@@_combine_aux:Vnf #1 { #2 }
	  {
	    \cs_to_str:N #1
	  }
  }

\cs_new_protected:Nn \rwobj_allocate_incr:NNnnNN
  {
    \rwobj_create_set:NnnfNN #1 { #3 }{ #4 }
      {
        \@@_combine:Nn #2 { #3 }
      }
      #5 #6

      \int_incr:N #2
  }

\cs_new_protected:Nn \rwobj_gallocate_incr:NNnnNN
  {
    \rwobj_create_gset:NnnfNN #1 { #3 }{ #4 }
      {
        \@@_combine:Nn #2 { #3 }
      }
      #5 #6

      \int_incr:N #2
  }

\cs_generate_variant:Nn \rwobj_allocate_incr:NNnnNN { NNVnNN }

\cs_generate_variant:Nn \rwobj_gallocate_incr:NNnnNN { NNVnNN }

\cs_new_protected:Nn \rwobj_allocate_gincr:NNnnNN
  {
    \rwobj_create_set:NnnfNN #1 { #3 }{ #4 }
      {
        \@@_combine:Nn #2 { #3 }
      }
      #5 #6

      \int_gincr:N #2
  }

\cs_new_protected:Nn \rwobj_gallocate_gincr:NNnnNN
  {
    \rwobj_create_gset:NnnfNN #1 { #3 }{ #4 }
      {
        \@@_combine:Nn #2 { #3 }
      }
      #5 #6

      \int_gincr:N #2
  }

\cs_generate_variant:Nn \rwobj_allocate_gincr:NNnnNN { NNVnNN }

\cs_generate_variant:Nn \rwobj_gallocate_gincr:NNnnNN { NNVnNN }

%    \end{macrocode}
% \end{macro}
%
%
%\begin{macro}{\rwobj_assign:nn}
%Copy an object to another one.
%    \begin{macrocode}
\cs_new_protected:Nn \rwobj_assign:nn
  {
    \seq_map_inline:cn
      {
        \rwobj_member_adr:vnn
          {
            \rwobj_ncmember_adr:nnn
              {
                \rwobj_embedded_adr:nn{ #1 }{ /_I_/ }
              }
              { P }{ str }
          }
          { varlist }{ seq }
      }
      {
        \rwobj_member_set_eq:nnc { #1 }{ ##1 }
          {
            \rwobj_member_adr:nn{ #2 }{ ##1 }
          }
      }
  }

\cs_generate_variant:Nn \rwobj_assign:nn { nV, Vn, VV }
%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%\end{implementation}
%
%\PrintIndex



