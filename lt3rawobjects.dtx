% \iffalse meta-comment
%
%  lt3rawobjects Objects and proxies in LaTeX3
%  Copyright (C) 2022  Paolo De Donato <dedonato95@hotmail.it>
%
%  This file is part of lt3rawobjects.
%
%  lt3rawobjects is free software: you can redistribute it and/or modify
%  it under the terms of the GNU General Public License as published by
%  the Free Software Foundation, either version 3 of the License, or
%  (at your option) any later version.
%
%  lt3rawobjects is distributed in the hope that it will be useful,
%  but WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  GNU General Public License for more details.
%
%  You should have received a copy of the GNU General Public License
%  along with lt3rawobjects.  If not, see <https://www.gnu.org/licenses/>.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{lt3rawobjects.dtx}[2022/12/27 2.3-beta-2 Objects and proxies in LaTeX3]
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}
%<package>\RequirePackage{expl3}[2022-04-10]
%<package>\ProvidesExplPackage{lt3rawobjects}{2022/12/27}{ 2.3-beta-2 }{Objects and proxies in LaTeX3}
%<*driver>
\documentclass[full]{l3doc}
\usepackage{lt3rawobjects}
\usepackage{xparse}
\begin{document}
\DocInput{lt3rawobjects.dtx}
\end{document}
%</driver>
% \fi
%
% \NewDocumentCommand{\thpkg}{}{\pkg{lt3rawobjects}}
% \NewDocumentCommand{\thvsn}{}{2.3-beta-2}
% \NewDocumentCommand{\thdta}{}{2022/12/27}
% \NewDocumentCommand{\fromV}{ m }{{\ttfamily From: #1}}
% \NewDocumentCommand{\fromVD}{ m m }{{\ttfamily From: #1}\par {\ttfamily Deprecated in: #2}}
%
% \title{The \pkg{lt3rawobjects} package}
%   \author{Paolo De Donato}
%   \date{Released on \thdta\ Version \thvsn}
%
% \maketitle
%
% \tableofcontents
%
% \begin{documentation}
%
% \section{Introduction}
% Package \thpkg\ introduces a new mechanism to create and manage structured data called ``objects'' like the well known C structures. The functions exported by this package are quite low level, and many important mechanisms like member protection and name resolution aren't already defined and should be introduced by intermediate packages. Higher level libraries built on top of \thpkg\ could also implement an improved and simplified syntax since the main focus of \thpkg\ is versatility and expandability rather than common usage.
%
% This packages follows the \href{https://semver.org/}{SemVer} specification (\texttt{https://semver.org/}). In particular any major version update (for example from \texttt{1.2} to \texttt{2.0}) may introduce imcompatible changes and so it's not advisable to work with different packages that require different major versions of \thpkg. Instead changes introduced in minor and patch version updates are always backward compatible, and any withdrawn function is declared deprecated instead of being removed.
%
% \section{Addresses}
% In this package a \emph{pure address} is any string without spaces (so a sequence of tokens with category code 12 ``other'') that uniquely identifies a resource or an entity. An example of pure address if the name of a control sequence \tn{\meta{name}} that can obtained by full expanding \cs{cs_to_str:N} \tn{\meta{name}}. Instead an \emph{expanded address} is a token list that contains only tokens with category code 11 (letters) or 12 (other) that can be directly converted to a pure address with a simple call to \cs{tl_to_str:n} or by assigning it to a string variable.
%
% An \emph{address} is instead a fully expandable token list which full expansion is an expanded address, where full expansion means the expansion process performed inside |c|, |x| and |e| parameters. Moreover, any address should be fully expandable according to the rules of |x| and |e| parameter types with same results, and the name of control sequence resulting from a |c|-type expansion of such address must be equal to its full expansion. For these reasons addresses should not contain parameter tokens like |#| (because they're threat differently by |x| and |e|) or control sequences that prevents expansion like \cs{exp_not:n} (because they leave unexpanded control sequences after an |x| or |e| expansion, and expanded addresses can't have control sequences inside them). In particular, |\tl_to_str:n{ ## }| is \emph{not} a valid address (assuming standard category codes).
%
% Addresses could be not full expanded inside an |f| argument, thus an address expanded in an |f| argument should be |x|, |e| or |c| expended later to get the actual pure address. If you need to fully expand an address in an |f| argument (because, for example, your macro should be fully expandable and your engine is too old to support |e| expansion efficiently) then you can put your address inside \cs{rwobj_address_f:n} and pass them to your function. For example,
% \begin{verbatim}
%   \your_function:f{ \rwobj_address_f:n { your \address } } 
% \end{verbatim}
% Remember that \cs{rwobj_address_f:n} only works with addresses, can't be used to fully expand any token list.
%
% Like functions and variables names, pure addresses should follows some basic naming conventions in order to avoid clashes between addresses in different modules. Each pure address starts with the \meta{module} name in which such address is allocated, then an underscore (|_|) and the \meta{identifier} that uniquely identifies the resource inside the module. The \meta{module} should contain only lowercase ASCII letters.
%
% A \emph{pointer} is just a \LaTeX3 string variable that holds a pure address. We don't enforce to use |str| or any special suffix to denote pointers so you're free to use |str| or a custom \meta{type} as suffix for your pointers in order to distinguish between them according to their type.
%
% In \thpkg\ all the macros ending with |_adr| or |_address| are fully expandable and can be used to compose valid addresses as explained in their documentation.
%
% \section{Objects}
% An \emph{object} is just a collection of several related entities called \emph{item}. Objects are themselves entities so they have addresses and could be contained inside other objects. Objects addresses are also used to compose the addresses of each of their inner entity, thus different objects can have items with the same name without clashing each other. Each object is uniquely identified by its pure address, which is composed by a \meta{module} and an \meta{identifier} as explained before. The use of underscore character in objects identifiers is reserved. You can retrive the address of an object via the \cs{object_address:nn} function.
%
% Objects are always created from already existing objects. An object that can be used to create other objects is called |proxy|, and the proxy that has created an object is its \emph{generator}. In the |rawobjects| module is already allocated a particular proxy that can be used to create every other proxy. Its identifier is just |proxy| and its pure address is stored in \cs{c_proxy_address_str}. The functions \cs{object_create} can be used to create new objects.
%
% \section{Items}
%  Remember that objects are just a collection of different items uniquely identidied by a pure address. Here an item could be one of the following entities:
% \begin{itemize}
%   \item a \LaTeX3 variable, in which case the item is called \emph{member};
%   \item a \LaTeX3 constant, in which case the item is called just \emph{constant};
%   \item a \LaTeX3 function, in which case the item is called \emph{method};
%   \item generic control sequences, in which case the item is called simply \emph{macro};
%   \item an entire object, in which case the item is called \emph{embedded object}.
% \end{itemize}
%
% Objects could be declared \emph{local} or \emph{global}. The only difference between a local and a global object is the scope of their members (that are \LaTeX3 variables). You should always create global object unless you specifically need local members.
%
% \subsection{Constants}
% Constants in an object could be \emph{near} and \emph{remote}. A near constant is just a constant declared in such object and could be referred only by it, instead a remote constant is declared inside its generator and can be referred by any object created from that proxy, thus it's shared between all the generated objects.
%
% Both near and remote constants are created in the same way, however remote constant should be created in a proxy whereas near contant are created directly in the target object.
%
% \subsection{Methods}
% Methods are \LaTeX3 functions that can't be changed once they're created. Like constant, methods could be near or remote.
%
% \subsection{Members}
% Members are just mutable \LaTeX3 variables. Members can be manually created inside objects or can be automatically created during object creation if their definitions are stored inside the generating proxy through the \cs{proxy_push_member} function. These members automatically created by proxies are called \emph{tracked} since the generator knows about them. Moreover, you don't need to specify the type of a tracked member since it can be inferred from the generator and the |assign| functions automatically copy all the tracked members in the new object.
%
% If the object is local/global then all its members are automatically local/global.
%
% \section{Put objects inside objects}
% Sometimes it's necessary to include other objects inside an object, and since objects are structured data types you can't put them directly inside a variable. However \thpkg\ provides some workarounds that allows you to include objects inside other objects, each with its own advantages and disadvantages.
%
% In the following examples we're in module |mymod| and we want to put inside object |A| another object created with proxy |prx|.  
%
% \subsection{Put a pointer variable} 
% A simple solution is creating that object outside |A| with \cs{object_create}
% \begin{verbatim}
%  \object_create:nnnNN 
%    { \object_address:nn{ mymod }{ prx } }{ mymod }{ B } ....
% \end{verbatim} 
% and then creating a pointer variable inside |A| (usually of type |tl| or |str|) holding the newly created address:
% \begin{verbatim}
%  \object_new_member:nnn
%    {
%      \object_address:nn{ mymod }{ A }
%    }{ pointer }{ tl }
%
%  \tl_(g)set:cn
%    {
%      \object_new_member:nnn
%        {
%          \object_address:nn{ mymod }{ A }
%        }{ pointer }{ tl }
%    }
%    {
%      \object_address:nn{ mymod }{ B }
%    }
%
% \end{verbatim}
% you can the access the pointed object by calling \cs{object_member_use} on |pointer| member.
%
% \subsubsection*{Advantages}
% \begin{itemize}
%   \item Simple and no additional function needed to create and manage included objects;
%   \item you can share the same object between different containers;
%   \item included objects are objects too, you can use address stored in pointer member just like any object address.
% \end{itemize}
% 
% \subsubsection*{Disadvantages}
% \begin{itemize}
%  \item You must manually create both the objects and link them;
%  \item creating objects also creates additional hidden variables, taking so (little) additional space.
% \end{itemize}
%
% \subsection{Clone the inner structure}
% Instead of referring a complete object you can just clone the inner structure of |prx| and put inside |A|. For example if |prx| declares member |x| of type |str| and member |y| of type |int| then you can do
% \begin{verbatim}
%  \object_new_member:nnn
%    {
%      \object_address:nn{ mymod }{ A }
%    }{ prx-x }{ str }
%  \object_new_member:nnn
%    {
%      \object_address:nn{ mymod }{ A }
%    }{ prx-y }{ int } 
% \end{verbatim} 
% and then use |prx-x|, |prx-y| as normal members of |A|.
%
% \subsubsection*{Advantages}
% \begin{itemize}
%  \item Simple and no additional function needed to create and manage included objects;
%  \item you can put these specifications inside a proxy so that every object created with it will  have the required members/methods;
%  \item no hidden variable created, lowest overhead among the proposed solutions.
% \end{itemize}
% 
% \subsubsection*{Disadvantages}
% \begin{itemize}
%  \item Cloning the inner structure doesn't create any object, so you don't have any object address nor you can share the included ``object'' unless you share the container object too.
% \end{itemize}
%
% \subsection{Embedded objects}
% From \thpkg\ \texttt{2.2} you can put \emph{embedded objects} inside objects. Embedded objects are created with \cs{embedded_create} function 
% \begin{verbatim}
%  \embedded_create:nnn 
%    { 
%      \object_address:nn{  mymod }{ A } 
%    }{ prx }{ B }
% \end{verbatim}
% and addresses of emmbedded objects can be retrieved with function \cs{object_embedded_adr}. You can also put the definition of embedded objects in a proxy by using \cs{proxy_push_embedded} just like \cs{proxy_push_member}.
%
% \subsubsection*{Advantages}
% \begin{itemize}
%   \item You can put a declaration inside a proxy so that embedded objects are automatically created during creation of parent object;
%   \item included objects are objects too, you can use address stored in pointer member just like any object address.
% \end{itemize}
% 
% \subsubsection*{Disadvantages}
% \begin{itemize}
%  \item Needs additional functions available for version \texttt{2.2} or later;
%  \item embedded objects must have the same scope and visibility of parent one; 
%  \item creating objects also creates additional hidden variables, taking so (little) additional space.
% \end{itemize}
%
% \section{Library functions}
% \label{sec:lib}
%
%  \subsection{Common functions}
%
% \begin{function}[EXP]{\rwobj_address_f:n}
%  \begin{syntax}
%   \cs{rwobj_address_f:n} \Arg{address}
%  \end{syntax}
%  Fully expand an address in an |f|-type argument.
%
%  \fromV{2.3}
% \end{function}
%
%  \subsection{Base object functions}
%
% \begin{function}[rEXP]{\object_address:nn}
%  \begin{syntax}
%   \cs{object_address:nn} \Arg{module} \Arg{id}
%  \end{syntax}
%  Composes the address of object in module \meta{module} with identifier \meta{id} and places it in the input stream. Notice that both \meta{module} and \meta{id} are converted to strings before composing them in the address, so they shouldn't contain any command inside.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\object_address_set:Nnn, \object_address_gset:Nnn}
%  \begin{syntax}
%   \cs{object_address_set:nn} \meta{str var} \Arg{module} \Arg{id}
%  \end{syntax}
%  Stores the adress of selected object inside the string variable \meta{str var}.
%
% \fromV{1.1}
% \end{function}
%
% \begin{function}[rEXP]{\object_embedded_adr:nn, \object_embedded_adr:Vn}
%  \begin{syntax}
%   \cs{object_embedded_adr:nn} \Arg{address} \Arg{id}
%  \end{syntax}
%  Compose the address of embedded object with name \meta{id} inside the parent object with address \meta{address}. Since an embedded object is also an object you can use this function for any function that accepts object addresses as an argument.
%
%  \fromV{2.2}
% \end{function}
%
% \begin{function}[pTF]{\object_if_exist:n, \object_if_exist:V}
%  \begin{syntax}
%   \cs{object_if_exist_p:n} \marg{address}
%   \cs{object_if_exist:nTF} \marg{address} \marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if an object was instantiated at the specified address.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}[EXP]{\object_get_module:n, \object_get_module:V, \object_get_proxy_adr:n, \object_get_proxy_adr:V}
%  \begin{syntax}
%   \cs{object_get_module:n} \marg{address}
%   \cs{object_get_proxy_adr:n} \marg{address}
%  \end{syntax}
%  Get the object module and its generator.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}[pTF]{\object_if_local:n, \object_if_global:n, \object_if_local:V, \object_if_global:V}
%  \begin{syntax}
%   \cs{object_if_local_p:n} \marg{address}
%   \cs{object_if_local:nTF} \marg{address} \marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if the object is local or global.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}[pTF]{\object_if_public:n, \object_if_private:n, \object_if_public:V, \object_if_private:V}
%  \begin{syntax}
%   \cs{object_if_public_p:n} \marg{address}
%   \cs{object_if_public:nTF} \marg{address} \marg{true code} \marg{false code}
%  \end{syntax}
%  Tests if the object is public or private.
%
% \fromV{1.0}
% \end{function}
%
%  \subsection{Members}
%
% \begin{function}[rEXP]{\object_member_adr:nnn, \object_member_adr:Vnn, \object_member_adr:nnv, \object_member_adr:nn, \object_member_adr:Vn}
%  \begin{syntax}
%   \cs{object_member_adr:nnn} \marg{address} \marg{member name} \marg{member type}
%   \cs{object_member_adr:nn} \marg{address} \marg{member name}
%  \end{syntax}
%  Fully expands to the address of specified member variable. If type is not specified it'll be retrieved from the generator proxy, but only if member is specified in the generator.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}[pTF]{\object_member_if_exist:nnn, \object_member_if_exist:Vnn, \object_member_if_exist:nn, \object_member_if_exist:Vn}
%  \begin{syntax}
%   \cs{object_member_if_exist_p:nnn} \marg{address} \marg{member name} \marg{member type}
%   \cs{object_member_if_exist:nnnTF} \marg{address} \marg{member name} \marg{member type} \Arg{true code} \Arg{false code}
%   \cs{object_member_if_exist_p:nn} \Arg{address} \Arg{member name}
%   \cs{object_member_if_exist:nnTF} \Arg{address} \Arg{member name} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if the specified member exist.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[EXP]{\object_member_type:nn, \object_member_type:Vn}
%  \begin{syntax}
%   \cs{object_member_type:nn} \marg{address} \marg{member name}
%  \end{syntax}
%  Fully expands to the type of member \meta{member name}. Use this function only with member variables specified in the generator proxy, not with other member variables.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\object_new_member:nnn, \object_new_member:Vnn, \object_new_member:nnv}
%  \begin{syntax}
%   \cs{object_new_member:nnn} \marg{address} \marg{member name} \marg{member type}
%  \end{syntax}
%  Creates a new member variable with specified name and type. You can't retrieve the type of these variables with \cs{object_member_type} functions.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}[EXP]{\object_member_use:nnn, \object_member_use:Vnn, \object_member_use:nnv, \object_member_use:nn, \object_member_use:Vn}
%  \begin{syntax}
%   \cs{object_member_use:nnn} \marg{address} \marg{member name} \marg{member type}
%   \cs{object_member_use:nn} \marg{address} \marg{member name}
%  \end{syntax}
%  Uses the specified member variable.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\object_member_set:nnnn, \object_member_set:nnvn, \object_member_set:Vnnn, \object_member_set:nnn, \object_member_set:Vnn}
%  \begin{syntax}
%   \cs{object_member_set:nnnn} \Arg{address} \Arg{member name} \Arg{member type} \Arg{value}
%   \cs{object_member_set:nnn} \Arg{address} \Arg{member name} \Arg{value}
%  \end{syntax}
%  Sets the value of specified member to \marg{value}. It calls implicitly \cs{\meta{member type}_(g)set:cn} then be sure to define it before calling this method.
%
% \fromV{2.1}
% \end{function}
%
% \begin{function}{\object_member_set_eq:nnnN, \object_member_set_eq:nnvN, \object_member_set_eq:VnnN, \object_member_set_eq:nnnc, \object_member_set_eq:Vnnc, \object_member_set_eq:nnN, \object_member_set_eq:VnN, \object_member_set_eq:nnc, \object_member_set_eq:Vnc}
%  \begin{syntax}
%   \cs{object_member_set_eq:nnnN} \marg{address} \marg{member name} \marg{member type} \meta{variable}
%   \cs{object_member_set_eq:nnN} \marg{address} \marg{member name} \meta{variable}
%  \end{syntax}
%  Sets the value of specified member equal to the value of \meta{variable}.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}[rEXP]{\object_ncmember_adr:nnn, \object_ncmember_adr:Vnn, \object_ncmember_adr:vnn, \object_rcmember_adr:nnn, \object_rcmember_adr:Vnn}
%  \begin{syntax}
%   \cs{object_ncmember_adr:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%  \end{syntax}
%  Fully expands to the address of specified near/remote constant member.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[pTF]{\object_ncmember_if_exist:nnn, \object_ncmember_if_exist:Vnn, \object_rcmember_if_exist:nnn, \object_rcmember_if_exist:Vnn}
%  \begin{syntax}
%   \cs{object_ncmember_if_exist_p:nnn} \marg{address} \marg{member name} \marg{member type}
%   \cs{object_ncmember_if_exist:nnnTF} \marg{address} \marg{member name} \marg{member type} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if the specified member constant exist.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[EXP]{\object_ncmember_use:nnn, \object_ncmember_use:Vnn, \object_rcmember_use:nnn, \object_rcmember_use:Vnn}
%  \begin{syntax}
%   \cs{object_ncmember_use:nnn} \Arg{address} \Arg{member name} \Arg{member type}
%  \end{syntax}
%  Uses the specified near/remote constant member.
%
% \fromV{2.0}
% \end{function}
%
% \subsection{Methods}
% Currentlu only constant methods (near and remote) are implemented in \thpkg\ as explained before.
%
% \begin{function}[rEXP]{\object_ncmethod_adr:nnn, \object_ncmethod_adr:Vnn, \object_ncmethod_adr:vnn, \object_rcmethod_adr:nnn, \object_rcmethod_adr:Vnn}
%  \begin{syntax}
%   \cs{object_ncmethod_adr:nnn} \Arg{address} \Arg{method name} \Arg{method variant}
%  \end{syntax}
%  Fully expands to the address of the specified
%  \begin{itemize}
%    \item near constant method if \cs{object_ncmethod_adr} is used;
%    \item remote constant method if \cs{object_rcmethod_adr} is used.
%  \end{itemize}
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[pTF]{\object_ncmethod_if_exist:nnn, \object_ncmethod_if_exist:Vnn, \object_rcmethod_if_exist:nnn, \object_rcmethod_if_exist:Vnn}
%  \begin{syntax}
%   \cs{object_ncmethod_if_exist_p:nnn} \marg{address} \marg{method name} \marg{method variant}
%   \cs{object_ncmethod_if_exist:nnnTF} \marg{address} \marg{method name} \marg{method variant} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Tests if the specified method constant exist.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}{\object_new_cmethod:nnnn, \object_new_cmethod:Vnnn}
%  \begin{syntax}
%   \cs{object_new_cmethod:nnnn} \Arg{address} \Arg{method name} \Arg{method arguments} \Arg{code}
%  \end{syntax}
%  Creates a new method with specified name and argument types. The \marg{method arguments} should be a string composed only by |n| and |N| characters that are passed to \cs{cs_new:Nn}.
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[EXP]{\object_ncmethod_call:nnn, \object_ncmethod_call:Vnn, \object_rcmethod_call:nnn, \object_rcmethod_call:Vnn}
%  \begin{syntax}
%   \cs{object_ncmethod_call:nnn} \marg{address} \marg{method name} \marg{method variant}
%  \end{syntax}
%  Calls the specified method. This function is expandable if and only if the specified method was not declared |protected|.
%
% \fromV{2.0}
% \end{function}
%
% \subsection{Constant member creation}
% Unlike normal variables, constant variables in \LaTeX3 are created in different ways depending on the specified type. So we dedicate a new section only to collect some of these fuinctions readapted for near constants (remote constants are simply near constants created on the generator proxy).
%
% \begin{function}{\object_newconst_tl:nnn, \object_newconst_tl:Vnn, \object_newconst_str:nnn, \object_newconst_str:Vnn, \object_newconst_int:nnn, \object_newconst_int:Vnn, \object_newconst_clist:nnn, \object_newconst_clist:Vnn, \object_newconst_dim:nnn, \object_newconst_dim:Vnn, \object_newconst_skip:nnn, \object_newconst_skip:Vnn, \object_newconst_fp:nnn, \object_newconst_fp:Vnn}
%  \begin{syntax}
%   \cs{object_newconst_\meta{type}:nnn} \Arg{address} \Arg{constant name} \Arg{value}
%  \end{syntax}
%  Creates a constant variable with type \meta{type} and sets its value to \meta{value}.
%
%  \fromV{1.1}
% \end{function}
%
% \begin{function}{\object_newconst_seq_from_clist:nnn, \object_newconst_seq_from_clist:Vnn}
%  \begin{syntax}
%   \cs{object_newconst_seq_from_clist:nnn} \Arg{address} \Arg{constant name} \Arg{comma-list}
%  \end{syntax}
%  Creates a |seq| constant which is set to contain all the items in \meta{comma-list}.
%
% \fromV{1.1}
% \end{function}
%
% \begin{function}{\object_newconst_prop_from_keyval:nnn, \object_newconst_prop_from_keyval:Vnn}
%  \begin{syntax}
%   \cs{object_newconst_prop_from_keyval:nnn} \Arg{address} \Arg{constant name}
%   \{
%   \meta{key} = \meta{value}, ...
%   \}
%  \end{syntax}
%  Creates a |prop| constant which is set to contain all the specified key-value pairs.
%
% \fromV{1.1}
% \end{function}
%
% \begin{function}{\object_newconst:nnnn}
%  \begin{syntax}
%   \cs{object_newconst:nnnn} \Arg{address} \Arg{constant name} \Arg{type} \Arg{value}
%  \end{syntax}
%  Expands to \cs{\meta{type}_const:cn} \marg{address} \marg{value}, use it if you need to create simple constants with custom types.
%
%  \fromV{2.1}
% \end{function}
%
% \subsection{Macros}
% 
% \begin{function}[rEXP]{\object_macro_adr:nn, \object_macro_adr:Vn}
%  \begin{syntax}
%   \cs{object_macro_adr:nn} \Arg{address} \Arg{macro name}
%  \end{syntax}
%  Address of specified macro.
%
%  \fromV{2.2}
% \end{function}
% 
% \begin{function}[EXP]{\object_macro_use:nn, \object_macro_use:Vn}
%  \begin{syntax}
%   \cs{object_macro_use:nn} \Arg{address} \Arg{macro name}
%  \end{syntax}
%  Uses the specified macro. This function is expandable if and only if the specified macro is it.
%
%  \fromV{2.2}
% \end{function}
%
% There isn't any standard function to create macros, and macro declarations can't be inserted in a |proxy| object. In fact a macro is just an unspecialized control sequence at the disposal of users that usually already know how to implement them. 
%
% \subsection{Proxy utilities and object creation}
%
% \begin{function}[pTF]{\object_if_proxy:n, \object_if_proxy:V}
%  \begin{syntax}
%   \cs{object_if_proxy_p:n} \marg{address}
%   \cs{object_if_proxy:nTF} \marg{address} \marg{true code} \marg{false code}
%  \end{syntax}
%  Test if the specified object is a proxy object.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}[pTF]{\object_test_proxy:nn, \object_test_proxy:Vn}
%  \begin{syntax}
%   \cs{object_test_proxy_p:nn} \Arg{object address} \Arg{proxy address}
%   \cs{object_test_proxy:nnTF} \Arg{object address} \Arg{proxy address} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Test if the specified object is generated by the selected proxy, where \meta{proxy variable} is a string variable holding the proxy address.
%
% \begin{texnote}
% Remember that this command uses internally an |e| expansion so in older engines (any different from Lua\LaTeX\ before 2019) it'll require slow processing. Don't use it in speed critical parts, instead use \cs{object_test_proxy:nN}.
% \end{texnote}
%
% \fromV{2.0}
% \end{function}
%
% \begin{function}[pTF]{\object_test_proxy:nN, \object_test_proxy:VN}
%  \begin{syntax}
%   \cs{object_test_proxy_p:nN} \Arg{object address} \meta{proxy variable}
%   \cs{object_test_proxy:nNTF} \Arg{object address} \meta{proxy variable} \Arg{true code} \Arg{false code}
%  \end{syntax}
%  Test if the specified object is generated by the selected proxy, where \meta{proxy variable} is a string variable holding the proxy address. The |:nN| variant don't use |e| expansion, instead of |:nn| command, so it can be safetly used with older compilers. 
%
% \fromV{2.0}
% \end{function}
%
% \begin{variable}{\c_proxy_address_str}
%  The address of the |proxy| object in the |rawobjects| module.
%
% \fromV{1.0}
% \end{variable}
%
% \begin{function}{\object_create:nnnNN, \object_create:VnnNN}
%  \begin{syntax}
%   \cs{object_create:nnnNN} \marg{proxy address} \marg{module} \marg{id} \meta{scope} \meta{visibility}
%  \end{syntax}
%  Creates an object by using the proxy at \meta{proxy address} and the specified parameters. Use this function only if you need to create private objects (at present private objects are functionally equivalent to public objects) or if you need to compile your project with an old version of this library (|< 2.3|).
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\object_create:nnnN, \object_create:VnnN, \object_create:nnn, \object_create:Vnn}
%  \begin{syntax}
%   \cs{object_create:nnnN} \Arg{proxy address} \Arg{module} \Arg{id} \meta{scope}\\
%   \cs{object_create:nnn} \Arg{proxy address} \Arg{module} \Arg{id}
%  \end{syntax}
%  Same as \cs{object_create:nnnNN} but both create only public objects, and the |:nnn| version only global ones. Always use these two function instead of \cs{object_create:nnnNN} unless you strictly need private objects.
%
% \fromV{2.3}
% \end{function}
%
% \begin{function}{\embedded_create:nnn, \embedded_create:Vnn, \embedded_create:nvn}
%  \begin{syntax}
%   \cs{embedded_create:nnn} \Arg{parent object} \Arg{proxy address} \Arg{id}
%  \end{syntax}
%  Creates an embedded object with name \meta{id} inside \meta{parent object}.
%
% \fromV{2.2}
% \end{function}
%
% \begin{variable}{\c_object_local_str, \c_object_global_str}
%  Possible values for \meta{scope} parameter.
%
% \fromV{1.0}
% \end{variable}
%
% \begin{variable}{\c_object_public_str, \c_object_private_str}
%  Possible values for \meta{visibility} parameter.
%
% \fromV{1.0}
% \end{variable}
%
% \begin{function}{\object_create_set:NnnnNN, \object_create_set:NVnnNN, \object_create_set:NnnfNN, \object_create_gset:NnnnNN, \object_create_gset:NVnnNN, \object_create_gset:NnnfNN}
%  \begin{syntax}
%   \cs{object_create_set:NnnnNN} \meta{str var} \marg{proxy address} \marg{module} \marg{id} \meta{scope} \meta{visibility}
%  \end{syntax}
%  Creates an object and sets its fully expanded address inside \meta{str var}.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\object_allocate_incr:NNnnNN, \object_allocate_incr:NNVnNN, \object_gallocate_incr:NNnnNN, \object_gallocate_incr:NNVnNN, \object_allocate_gincr:NNnnNN, \object_allocate_gincr:NNVnNN, \object_gallocate_gincr:NNnnNN, \object_gallocate_gincr:NNVnNN}
%  \begin{syntax}
%   \cs{object_allocate_incr:NNnnNN} \meta{str var} \meta{int var} \Arg{proxy address} \Arg{module} \meta{scope} \meta{visibility}
%  \end{syntax}
%  Build a new object address with module \meta{module} and an identifier generated from \meta{proxy address} and the integer contained inside \meta{int var}, then increments \meta{int var}. This is very useful when you need to create a lot of objects, each of them on a different address. the |_incr| version increases \meta{int var} locally whereas |_gincr| does it globally.
%
% \fromV{1.1}
% \end{function}
%
% \begin{function}{\proxy_create:nnN, \proxy_create_set:NnnN, \proxy_create_gset:NnnN}
%  \begin{syntax}
%   \cs{proxy_create:nnN} \Arg{module} \Arg{id} \meta{visibility}
%   \cs{proxy_create_set:NnnN} \meta{str var} \Arg{module} \Arg{id} \meta{visibility}
%  \end{syntax}
% These commands are deprecated because proxies should be global and public. Use instead \cs{proxy_create:nn}, \cs{proxy_create_set:Nnn} and \cs{proxy_create_gset:Nnn}.
%
% \fromVD{1.0}{2.3}
% \end{function}
%
% \begin{function}{\proxy_create:nn, \proxy_create_set:Nnn, \proxy_create_gset:Nnn}
%  \begin{syntax}
%   \cs{proxy_create:nn} \Arg{module} \Arg{id}
%   \cs{proxy_create_set:Nnn} \meta{str var} \Arg{module} \Arg{id}
%  \end{syntax}
%  Creates a global public proxy object.
%
% \fromV{2.3}
% \end{function}
%
% \begin{function}{\proxy_push_member:nnn, \proxy_push_member:Vnn}
%  \begin{syntax}
%   \cs{proxy_push_member:nnn} \Arg{proxy address} \Arg{member name} \Arg{member type}
%  \end{syntax}
%  Updates a proxy object with a new member specification, so that every subsequential object created with this proxy will have a member variable with the specified name and type that can be retrieved with \cs{object_member_type} functions.
%
% \fromV{1.0}
% \end{function}
%
% \begin{function}{\proxy_push_embedded:nnn, \proxy_push_embedded:Vnn}
%  \begin{syntax}
%   \cs{proxy_push_embedded:nnn} \Arg{proxy address} \Arg{embedded object name} \Arg{embedded object proxy}
%  \end{syntax}
%  Updates a proxy object with a new embedded object specification.
%
% \fromV{2.2}
% \end{function}
%
% \begin{function}{\proxy_add_initializer:nN, \proxy_add_initializer:VN}
%  \begin{syntax}
%   \cs{proxy_add_initializer:nN} \Arg{proxy address} \meta{initializer}
%  \end{syntax}
%  Pushes a new initializer that will be executed on each created objects. An initializer is a function that should accept five arguments in this order:
%  \begin{itemize}
%   \item the full expanded address of used proxy as an |n| argument;
%   \item the module name as an |n| argument;
%   \item the full expanded address of created object as an |n| argument.
%  \end{itemize}
%
%  Initializer will be executed in the same order they're added.
% \end{function}
%
% \begin{function}{\object_assign:nn, \object_assign:Vn, \object_assign:nV, \object_assign:VV}
%  \begin{syntax}
%   \cs{object_assign:nn} \marg{to address} \marg{from address}
%  \end{syntax}
%  Assigns the content of each variable of object at \meta{from address} to each correspective variable in \meta{to address}. Both the objects should be created with the same proxy object and only variables listed in the proxy are assigned.
%
% \fromV{1.0}
% \end{function}
%
% \section{Examples}
%  \subsection*{Example 1}
% Create a public proxy with id \verb|myproxy| with the specification of a single member variable with name \verb|myvar| and type \verb|tl|, then set its address inside \cs{g_myproxy_str}.
%
% \begin{verbatim}
% \str_new:N \g_myproxy_str
% \proxy_create_gset:Nnn \g_myproxy_str { example }{ myproxy }
% \proxy_push_member:Vnn \g_myproxy_str { myvar }{ tl }
% \end{verbatim}
%
% Then create a new object with name \verb|myobj| with that proxy, assign then token list \verb|\c_dollar_str{} ~ dollar ~ \c_dollar_str{}| to \verb|myvar| and then print it.
%
% \begin{verbatim}
% \str_new:N \g_myobj_str
% \object_create_gset:NVnn \g_myobj_str \g_myproxy_str
%   { example }{ myobj }
% \tl_gset:cn
%   {
%     \object_member_adr:Vn \g_myobj_str { myvar }
%   }
%   { \c_dollar_str{} ~ dollar ~ \c_dollar_str{} }
% \object_member_use:Vn \g_myobj_str { myvar }
% \end{verbatim}
%
% Output: \ExplSyntaxOn
% \str_new:N \g_myproxy_str
% \proxy_create_gset:Nnn \g_myproxy_str { example }{ myproxy }
% \proxy_push_member:Vnn \g_myproxy_str { myvar }{ tl }
% \str_new:N \g_myobj_str
% \object_create_gset:NVnn \g_myobj_str \g_myproxy_str
%   { example }{ myobj }
% \tl_gset:cn
%   {
%     \object_member_adr:Vn \g_myobj_str { myvar }
%   }
%   { \c_dollar_str{} ~ dollar ~ \c_dollar_str{} }
% \object_member_use:Vn \g_myobj_str { myvar }
% \ExplSyntaxOff
%
% If you don't want to specify an object identifier you can also do
%
% \begin{verbatim}
% \int_new:N \g_intc_int
% \object_gallocate_gincr:NNVnNN \g_myobj_str \g_intc_int \g_myproxy_str
%   { example } \c_object_local_str \c_object_public_str
% \tl_gset:cn
%   {
%     \object_member_adr:Vn \g_myobj_str { myvar }
%   }
%   { \c_dollar_str{} ~ dollar ~ \c_dollar_str{} }
% \object_member_use:Vn \g_myobj_str { myvar }
% \end{verbatim}
%
% Output: \ExplSyntaxOn
% \int_new:N \g_intc_int
% \object_gallocate_gincr:NNVnNN \g_myobj_str \g_intc_int \g_myproxy_str
%   { example } \c_object_local_str \c_object_public_str
% \tl_gset:cn
%   {
%     \object_member_adr:Vn \g_myobj_str { myvar }
%   }
%   { \c_dollar_str{} ~ dollar ~ \c_dollar_str{} }
% \object_member_use:Vn \g_myobj_str { myvar }
% \ExplSyntaxOff
%
% \subsection*{Example 2}
% In this example we create a proxy object with an embedded object inside.
%
% Internal proxy
% \begin{verbatim}
%  \proxy_create:nn{ mymod }{ INT }
%  \proxy_push_member:nnn
%    {
%      \object_address:nn{ mymod }{ INT }
%    }{ var }{ tl }
% \end{verbatim}
%
% Container proxy
% \begin{verbatim}
%  \proxy_create:nn{ mymod }{ EXT }
%  \proxy_push_embedded:nnn
%    {
%      \object_address:nn{ mymod }{ EXT }
%    }
%    { emb }
%    {
%      \object_address:nn{ mymod }{ INT }
%    }
% \end{verbatim}
%
% Now we create a new object from proxy |EXT|. It'll contain an embedded object created with |INT| proxy:
% \begin{verbatim}
%  \str_new:N \g_EXTobj_str
%  \int_new:N \g_intcount_int
%  \object_gallocate_gincr:NNnnNN
%    \g_EXTobj_str \g_intcount_int
%    {
%      \object_address:nn{ mymod }{ EXT }
%    }
%    { mymod }
%    \c_object_local_str \c_object_public_str
% \end{verbatim}
% and use the embedded object in the following way:
% \begin{verbatim}
%  \object_member_set:nnn
%    {
%      \object_embedded_adr:Vn \g_EXTobj_str { emb }
%    }{ var }{ Hi }
%  \object_member_use:nn
%    {
%      \object_embedded_adr:Vn \g_EXTobj_str { emb }
%    }{ var }
% \end{verbatim}
% Output: \ExplSyntaxOn
%  \proxy_create:nn{ mymod }{ INT }
%  \proxy_push_member:nnn
%    {
%      \object_address:nn{ mymod }{ INT }
%    }{ var }{ tl }
%
%  \proxy_create:nn{ mymod }{ EXT }
%  \proxy_push_embedded:nnn
%    {
%      \object_address:nn{ mymod }{ EXT }
%    }
%    { emb }
%    {
%      \object_address:nn{ mymod }{ INT }
%    }
%
%  \str_new:N \g_EXTobj_str
%  \int_new:N \g_intcount_int
%  \object_gallocate_gincr:NNnnNN
%    \g_EXTobj_str \g_intcount_int
%    {
%      \object_address:nn{ mymod }{ EXT }
%    }
%    { mymod }
%    \c_object_local_str \c_object_public_str
%
%  \object_member_set:nnn
%    {
%      \object_embedded_adr:Vn \g_EXTobj_str { emb }
%    }{ var }{ Hi }
%  \object_member_use:nn
%    {
%      \object_embedded_adr:Vn \g_EXTobj_str { emb }
%    }{ var }
% \ExplSyntaxOff
%
%\end{documentation}
%
%\begin{implementation}
%
%\section{Implementation}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=rawobjects>
%    \end{macrocode}
%
% Deprecation message
%    \begin{macrocode}

\msg_new:nnn { rawobjects }{ deprecate }
  {
    Command ~ #1 ~ is ~ deprecated. ~ Use ~ instead ~ #2
  }

\cs_new_protected:Nn \@@_launch_deprecate:NN
  {
    \msg_warning:nnnn{ rawobjects }{ deprecate }{ #1 }{ #2 }
  }

%    \end{macrocode}
%
% \begin{macro}{\rwobj_address_f:n}
% It just performs a |c| expansion before passing it to \cs{cs_to_str:N}.
%    \begin{macrocode}

\cs_new:Nn \rwobj_address_f:n
  {
    \exp_args:Nc \cs_to_str:N { #1 }
  }

%    \end{macrocode}
% \end{macro}

%\begin{variable}{\c_object_local_str, \c_object_global_str, \c_object_public_str, \c_object_private_str}
%    \begin{macrocode}
\str_const:Nn \c_object_local_str {l}
\str_const:Nn \c_object_global_str {g}
\str_const:Nn \c_object_public_str {_}
\str_const:Nn \c_object_private_str {__}


\cs_new:Nn \@@_scope:N
  {
    \str_use:N #1
  }

\cs_new:Nn \@@_scope_pfx:N
  {
    \str_if_eq:NNF #1 \c_object_local_str
      { g }
  }
  
\cs_generate_variant:Nn \@@_scope_pfx:N { c }

\cs_new:Nn \@@_scope_pfx_cl:n 
  {
    \@@_scope_pfx:c{
	  \object_ncmember_adr:nnn 
	    {
		  \object_embedded_adr:nn { #1  }{ /_I_/ }
		}
		{ S }{ str }
	}
  }  

\cs_new:Nn \@@_vis_var:N
  {
    \str_use:N #1
  }

\cs_new:Nn \@@_vis_fun:N
  {
    \str_if_eq:NNT #1 \c_object_private_str
      {
        __
      }
  }

%    \end{macrocode}
%\end{variable}
%
%\begin{macro}{\object_address:nn}
%Get address of an object
%    \begin{macrocode}
\cs_new:Nn \object_address:nn {
  \tl_to_str:n { #1  _  #2 }
}
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\object_embedded_adr:nn}
% Address of embedded object
%    \begin{macrocode}

\cs_new:Nn \object_embedded_adr:nn
  {
    #1 \tl_to_str:n{ _SUB_ #2 }
  }
  
\cs_generate_variant:Nn \object_embedded_adr:nn{ Vn }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\object_address_set:Nnn, \object_address_gset:Nnn}
% Saves the address of an object into a string variable
%    \begin{macrocode}

\cs_new_protected:Nn \object_address_set:Nnn {
  \str_set:Nn #1 { #2  _  #3 }
}

\cs_new_protected:Nn \object_address_gset:Nnn {
  \str_gset:Nn #1 { #2  _  #3 }
}

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[pTF]{\object_if_exist:n}
%Tests if object exists.
%    \begin{macrocode}

\prg_new_conditional:Nnn \object_if_exist:n { p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { S }{ str }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_generate_conditional_variant:Nnn \object_if_exist:n { V }
  { p, T, F, TF }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\object_get_module:n, \object_get_proxy_adr:n}
%Retrieve the name, module and generating proxy of an object
%    \begin{macrocode}
\cs_new:Nn \object_get_module:n {
  \object_ncmember_use:nnn
  {
    \object_embedded_adr:nn{ #1 }{ /_I_/ }
  }
  { M }{ str }
}
\cs_new:Nn \object_get_proxy_adr:n {
  \object_ncmember_use:nnn
  {
    \object_embedded_adr:nn{ #1 }{ /_I_/ }
  }
  { P }{ str }
}

\cs_generate_variant:Nn \object_get_module:n { V }
\cs_generate_variant:Nn \object_get_proxy_adr:n { V }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[pTF]{\object_if_local:n, \object_if_global:n, \object_if_public:n, \object_if_private:n}
%Test the specified parameters.
%    \begin{macrocode}
\prg_new_conditional:Nnn \object_if_local:n {p, T, F, TF}
{
  \str_if_eq:cNTF
    {
      \object_ncmember_adr:nnn
        {
          \object_embedded_adr:nn{ #1 }{ /_I_/ }
        }
        { S }{ str }
    }
    \c_object_local_str
    {
      \prg_return_true:
    }
    {
      \prg_return_false:
    }
}

\prg_new_conditional:Nnn \object_if_global:n {p, T, F, TF}
{
  \str_if_eq:cNTF
    {
      \object_ncmember_adr:nnn
        {
          \object_embedded_adr:nn{ #1 }{ /_I_/ }
        }
        { S }{ str }
    }
    \c_object_global_str
    {
      \prg_return_true:
    }
    {
      \prg_return_false:
    }
}

\prg_new_conditional:Nnn \object_if_public:n {p, T, F, TF}
{
  \str_if_eq:cNTF
    {
      \object_ncmember_adr:nnn
        {
          \object_embedded_adr:nn{ #1 }{ /_I_/ }
        }
        { V }{ str }
    }
    \c_object_public_str
    {
      \prg_return_true:
    }
    {
      \prg_return_false:
    }
}

\prg_new_conditional:Nnn \object_if_private:n {p, T, F, TF}
{
  \str_if_eq:cNTF
    {
      \object_ncmember_adr:nnn
        {
          \object_embedded_adr:nn{ #1 }{ /_I_/ }
        }
        { V }{ str }
    }
    \c_object_private_str
    {
      \prg_return_true:
    }
    {
      \prg_return_false:
    }
}

\prg_generate_conditional_variant:Nnn \object_if_local:n { V }
  { p, T, F, TF }
\prg_generate_conditional_variant:Nnn \object_if_global:n { V }
  { p, T, F, TF }
\prg_generate_conditional_variant:Nnn \object_if_public:n { V }
  { p, T, F, TF }
\prg_generate_conditional_variant:Nnn \object_if_private:n { V }
  { p, T, F, TF }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\object_macro_adr:nn, \object_macro_use:nn}
% Generic macro address
%    \begin{macrocode}

\cs_new:Nn \object_macro_adr:nn
  {
    #1 \tl_to_str:n{ _MACRO_ #2 }
  }
  
\cs_generate_variant:Nn \object_macro_adr:nn{ Vn }

\cs_new:Nn \object_macro_use:nn
  {
    \use:c
      {
        \object_macro_adr:nn{ #1 }{ #2 }
      }
  }
  
\cs_generate_variant:Nn \object_macro_use:nn{ Vn }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\@@_member_adr:nnnNN}
% Macro address without object inference
%    \begin{macrocode}

\cs_new:Nn \@@_member_adr:nnnNN
  {
    \@@_scope:N #4
    \@@_vis_var:N #5
    #1 \tl_to_str:n { _ MEMBER _ #2 _ #3 }
  }
  
\cs_generate_variant:Nn \@@_member_adr:nnnNN { VnnNN, nnncc }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\object_member_adr:nnn, \object_member_adr:nn}
%Get the address of a member variable
%    \begin{macrocode}

\cs_new:Nn \object_member_adr:nnn
  {
    \@@_member_adr:nnncc { #1 }{ #2 }{ #3 }
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { S }{ str }
      }
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { V }{ str }
      }
  }

\cs_generate_variant:Nn \object_member_adr:nnn { Vnn, vnn, nnv }

\cs_new:Nn \object_member_adr:nn
  {
    \object_member_adr:nnv { #1 }{ #2 }
      {
        \object_rcmember_adr:nnn { #1 }
          { #2 _ type }{ str }
      }
  }

\cs_generate_variant:Nn \object_member_adr:nn { Vn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\object_member_type:nn}
%Deduce the member type from the generating proxy.
%    \begin{macrocode}

\cs_new:Nn \object_member_type:nn
  {
    \object_rcmember_use:nnn { #1 }
      { #2 _ type }{ str }
  }

%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}

\msg_new:nnnn { rawobjects }{ noerr }{ Unspecified ~ scope }
  {
    Object ~ #1 ~ hasn't ~ a ~ scope ~ variable
  }

\msg_new:nnnn { rawobjects }{ scoperr }{ Nonstandard ~ scope }
  {
    Operation ~ not ~ permitted ~ on ~ object ~ #1 ~
    ~ since ~ it ~ wasn't ~ declared ~ local ~ or ~ global
  }

\cs_new_protected:Nn \@@_force_scope:n
  {
    \cs_if_exist:cTF
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { S }{ str }
      }
      {
        \bool_if:nF
          {
            \object_if_local_p:n { #1 } || \object_if_global_p:n { #1 }
          }
          {
            \msg_error:nnx { rawobjects }{ scoperr }{ #1 }
          }
      }
      {
        \msg_error:nnx { rawobjects }{ noerr }{ #1 }
      }
  }

%    \end{macrocode}
%
% \begin{macro}[pTF]{\object_member_if_exist:nnn, \object_member_if_exist:nn}
% Tests if the specified member exists
%    \begin{macrocode}

\prg_new_conditional:Nnn \object_member_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_member_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_new_conditional:Nnn \object_member_if_exist:nn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_member_adr:nn { #1 }{ #2 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_generate_conditional_variant:Nnn \object_member_if_exist:nnn
  { Vnn }{ p, T, F, TF }
\prg_generate_conditional_variant:Nnn \object_member_if_exist:nn
  { Vn }{ p, T, F, TF }

%    \end{macrocode}
% \end{macro}

%\begin{macro}{\object_new_member:nnn}
%Creates a new member variable
%    \begin{macrocode}

\msg_new:nnnn{ rawobjects }{ nonew }{ Invalid ~ basic ~ type }{ Basic ~ type ~ #1 ~ doesn't ~have ~ function ~ #1_new:c }

\cs_new_protected:Nn \object_new_member:nnn
  {
    \cs_if_exist_use:cTF { #3 _ new:c }
      {
        { \object_member_adr:nnn { #1 }{ #2 }{ #3 } }
      }
      {
        \msg_error:nnn{ rawobjects }{ nonew }{ #3 }
      }
  }
  
\cs_generate_variant:Nn \object_new_member:nnn { Vnn, nnv }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\object_member_use:nnn, \object_member_use:nn}
%Uses a member variable
%    \begin{macrocode}

\cs_new:Nn \object_member_use:nnn
  {
    \cs_if_exist_use:cT { #3 _ use:c }
      {
        { \object_member_adr:nnn { #1 }{ #2 }{ #3 } }
      }
  }

\cs_new:Nn \object_member_use:nn
  {
    \object_member_use:nnv { #1 }{ #2 }
      {
        \object_rcmember_adr:nnn { #1 }
          { #2 _ type }{ str }
      }
  }

\cs_generate_variant:Nn \object_member_use:nnn { Vnn, vnn, nnv }
\cs_generate_variant:Nn \object_member_use:nn { Vn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\object_member_set:nnnn, \object_member_set_eq:nnn}
% Set the value a member.
%    \begin{macrocode}

\cs_new_protected:Nn \object_member_set:nnnn
  {
    \cs_if_exist_use:cT
      {
        #3 _ \@@_scope_pfx_cl:n{ #1 } set:cn
      }
      {
        { \object_member_adr:nnn { #1 }{ #2 }{ #3 } }
        { #4 }
      }
  }

\cs_generate_variant:Nn \object_member_set:nnnn { Vnnn, nnvn }

\cs_new_protected:Nn \object_member_set:nnn
  {
    \object_member_set:nnvn { #1 }{ #2 }
      {
        \object_rcmember_adr:nnn { #1 }
          { #2 _ type }{ str }
      } { #3 }
  }

\cs_generate_variant:Nn \object_member_set:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\object_member_set_eq:nnnN, \object_member_set_eq:nnN}
% Make a member equal to another variable.
%    \begin{macrocode}

\cs_new_protected:Nn \object_member_set_eq:nnnN
  {
    \@@_force_scope:n { #1 }
    \cs_if_exist_use:cT
      {
        #3 _ \@@_scope_pfx:n { #1 } set _ eq:cN
      }
      {
        { \object_member_adr:nnn { #1 }{ #2 }{ #3 } } #4
      }
  }

\cs_generate_variant:Nn \object_member_set_eq:nnnN { VnnN, nnnc, Vnnc, nnvN }

\cs_new_protected:Nn \object_member_set_eq:nnN
  {
    \object_member_set_eq:nnvN { #1 }{ #2 }
      {
        \object_rcmember_adr:nnn { #1 }
          { #2 _ type }{ str }
      } #3
  }

\cs_generate_variant:Nn \object_member_set_eq:nnN { VnN, nnc, Vnc }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\object_ncmember_adr:nnn}
% Get address of near constant
%    \begin{macrocode}

\cs_new:Nn \object_ncmember_adr:nnn
  {
    \tl_to_str:n{ c _ } #1 \tl_to_str:n { _ CONST _ #2 _ #3 }
  }

\cs_generate_variant:Nn \object_ncmember_adr:nnn { Vnn, vnn }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\object_rcmember_adr:nnn}
% Get the address of a remote constant.
%    \begin{macrocode}

\cs_new:Nn \object_rcmember_adr:nnn
  {
    \object_ncmember_adr:vnn
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { P }{ str }
      }
      { #2 }{ #3 }
  }

\cs_generate_variant:Nn \object_rcmember_adr:nnn { Vnn }
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}[pTF]{\object_ncmember_if_exist:nnn, \object_rcmember_if_exist:nnn}
% Tests if the specified member constant exists.
%    \begin{macrocode}

\prg_new_conditional:Nnn \object_ncmember_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_ncmember_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_new_conditional:Nnn \object_rcmember_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_rcmember_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_generate_conditional_variant:Nnn \object_ncmember_if_exist:nnn
  { Vnn }{ p, T, F, TF }
\prg_generate_conditional_variant:Nnn \object_rcmember_if_exist:nnn
  { Vnn }{ p, T, F, TF }

%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{\object_ncmember_use:nnn, \object_rcmember_use:nnn}
% Uses a near/remote constant.
%    \begin{macrocode}

\cs_new:Nn \object_ncmember_use:nnn
  {
    \cs_if_exist_use:cT { #3 _ use:c }
      {
        { \object_ncmember_adr:nnn { #1 }{ #2 }{ #3 } }
      }
  }

\cs_new:Nn \object_rcmember_use:nnn
  {
    \cs_if_exist_use:cT { #3 _ use:c }
      {
        { \object_rcmember_adr:nnn { #1 }{ #2 }{ #3 } }
      }
  }

\cs_generate_variant:Nn \object_ncmember_use:nnn { Vnn }
\cs_generate_variant:Nn \object_rcmember_use:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\object_newconst:nnnn}
% Creates a constant variable, use with caution
%    \begin{macrocode}

\cs_new_protected:Nn \object_newconst:nnnn
  {
    \use:c { #3 _ const:cn }
      {
        \object_ncmember_adr:nnn { #1 }{ #2 }{ #3 }
      }
      { #4 }
  }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\object_newconst_tl:nnn, \object_newconst_str:nnn, \object_newconst_int:nnn, \object_newconst_clist:nnn, \object_newconst_dim:nnn, \object_newconst_skip:nnn, \object_newconst_fp:nnn}
% Create constants
%    \begin{macrocode}

\cs_new_protected:Nn \object_newconst_tl:nnn
  {
    \object_newconst:nnnn { #1 }{ #2 }{ tl }{ #3 }
  }
\cs_new_protected:Nn \object_newconst_str:nnn
  {
    \object_newconst:nnnn { #1 }{ #2 }{ str }{ #3 }
  }
\cs_new_protected:Nn \object_newconst_int:nnn
  {
    \object_newconst:nnnn { #1 }{ #2 }{ int }{ #3 }
  }
\cs_new_protected:Nn \object_newconst_clist:nnn
  {
    \object_newconst:nnnn { #1 }{ #2 }{ clist }{ #3 }
  }
\cs_new_protected:Nn \object_newconst_dim:nnn
  {
    \object_newconst:nnnn { #1 }{ #2 }{ dim }{ #3 }
  }
\cs_new_protected:Nn \object_newconst_skip:nnn
  {
    \object_newconst:nnnn { #1 }{ #2 }{ skip }{ #3 }
  }
\cs_new_protected:Nn \object_newconst_fp:nnn
  {
    \object_newconst:nnnn { #1 }{ #2 }{ fp }{ #3 }
  }

\cs_generate_variant:Nn \object_newconst_tl:nnn { Vnn }
\cs_generate_variant:Nn \object_newconst_str:nnn { Vnn }
\cs_generate_variant:Nn \object_newconst_int:nnn { Vnn }
\cs_generate_variant:Nn \object_newconst_clist:nnn { Vnn }
\cs_generate_variant:Nn \object_newconst_dim:nnn { Vnn }
\cs_generate_variant:Nn \object_newconst_skip:nnn { Vnn }
\cs_generate_variant:Nn \object_newconst_fp:nnn { Vnn }


\cs_generate_variant:Nn \object_newconst_str:nnn { nnx }
\cs_generate_variant:Nn \object_newconst_str:nnn { nnV }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\object_newconst_seq_from_clist:nnn}
%  Creates a |seq| constant.
%    \begin{macrocode}

\cs_new_protected:Nn \object_newconst_seq_from_clist:nnn
  {
    \seq_const_from_clist:cn
      {
        \object_ncmember_adr:nnn { #1 }{ #2 }{ seq }
      }
      { #3 }
  }

\cs_generate_variant:Nn \object_newconst_seq_from_clist:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\object_newconst_prop_from_keyval:nnn}
%  Creates a |prop| constant.
%    \begin{macrocode}

\cs_new_protected:Nn \object_newconst_prop_from_keyval:nnn
  {
    \prop_const_from_keyval:cn
      {
        \object_ncmember_adr:nnn { #1 }{ #2 }{ prop }
      }
      { #3 }
  }

\cs_generate_variant:Nn \object_newconst_prop_from_keyval:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
%
% \begin{macro}{\object_ncmethod_adr:nnn, \object_rcmethod_adr:nnn}
% Fully expands to the method address.
%    \begin{macrocode}

\cs_new:Nn \object_ncmethod_adr:nnn
  {
    #1 \tl_to_str:n { _ CMETHOD _ #2 : #3 }
  }

\cs_generate_variant:Nn \object_ncmethod_adr:nnn { Vnn , vnn }

\cs_new:Nn \object_rcmethod_adr:nnn
  {
    \object_ncmethod_adr:vnn
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { P }{ str }
      }
      { #2 }{ #3 }
  }

\cs_generate_variant:Nn \object_ncmethod_adr:nnn { Vnn , vnn }
\cs_generate_variant:Nn \object_rcmethod_adr:nnn { Vnn }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\object_ncmethod_if_exist:nnn, \object_rcmethod_if_exist:nnn}
% Tests if the specified member constant exists.
%    \begin{macrocode}

\prg_new_conditional:Nnn \object_ncmethod_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_ncmethod_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_new_conditional:Nnn \object_rcmethod_if_exist:nnn {p, T, F, TF }
  {
    \cs_if_exist:cTF
      {
        \object_rcmethodr_adr:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_generate_conditional_variant:Nnn \object_ncmethod_if_exist:nnn
  { Vnn }{ p, T, F, TF }
\prg_generate_conditional_variant:Nnn \object_rcmethod_if_exist:nnn
  { Vnn }{ p, T, F, TF }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\object_new_cmethod:nnnn}
% Creates a new method
%    \begin{macrocode}

\cs_new_protected:Nn \object_new_cmethod:nnnn
  {
    \cs_new:cn
	  {
	    \object_ncmethod_adr:nnn { #1 }{ #2 }{ #3 }
	  }
	  { #4 }
  }
  
\cs_generate_variant:Nn \object_new_cmethod:nnnn { Vnnn }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\object_ncmethod_call:nnn, \object_rcmethod_call:nnn}
% Calls the specified method.
%    \begin{macrocode}

\cs_new:Nn \object_ncmethod_call:nnn
  {
    \use:c
	  {
	    \object_ncmethod_adr:nnn { #1 }{ #2 }{ #3 }
	  }
  }

\cs_new:Nn \object_rcmethod_call:nnn
  {
    \use:c
	  {
	    \object_rcmethod_adr:nnn { #1 }{ #2 }{ #3 }
	  }
  }
  
\cs_generate_variant:Nn \object_ncmethod_call:nnn { Vnn }
\cs_generate_variant:Nn \object_rcmethod_call:nnn { Vnn }

%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}

\cs_new_protected:Nn \@@_initproxy:nnn
  {
    \object_newconst:nnnn
      {
        \object_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { ifprox }{ bool }{ \c_true_bool }
  }
\cs_generate_variant:Nn \@@_initproxy:nnn { VnV }

%    \end{macrocode}
%
%
%\begin{macro}[pTF]{\object_if_proxy:n}
%Test if an object is a proxy.
%    \begin{macrocode}

\cs_new:Nn \@@_bol_com:N
  {
    \cs_if_exist_p:N #1 && \bool_if_p:N #1
  }

\cs_generate_variant:Nn \@@_bol_com:N { c }

\prg_new_conditional:Nnn \object_if_proxy:n {p, T, F, TF}
  {
    \cs_if_exist:cTF
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { ifprox }{ bool }
      }
      {
        \bool_if:cTF
          {
            \object_ncmember_adr:nnn
              {
                \object_embedded_adr:nn{ #1 }{ /_I_/ }
              }
              { ifprox }{ bool }
          }
          {
            \prg_return_true:
          }
          {
            \prg_return_false:
          }
      }
      {
        \prg_return_false:
      }
  }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[pTF]{\object_test_proxy:nn, \object_test_proxy:nN}
%Test if an object is generated from selected proxy.
%    \begin{macrocode}

\prg_generate_conditional_variant:Nnn \str_if_eq:nn { ve }{ TF }

\prg_new_conditional:Nnn \object_test_proxy:nn {p, T, F, TF}
  {
    \str_if_eq:veTF
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { P }{ str }
      }
	  { #2 }
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }

\prg_new_conditional:Nnn \object_test_proxy:nN {p, T, F, TF}
  {
    \str_if_eq:cNTF
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { P }{ str }
      }
	  #2
      {
        \prg_return_true:
      }
      {
        \prg_return_false:
      }
  }
  
\prg_generate_conditional_variant:Nnn \object_test_proxy:nn
  { Vn }{p, T, F, TF}
\prg_generate_conditional_variant:Nnn \object_test_proxy:nN
  { VN }{p, T, F, TF}

%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{\object_create:nnnNN, \object_create_set:NnnnNN, \object_create_gset:NnnnNN, \object_create:nnnN, \object_create_set:NnnnN, \object_create_gset:NnnnN, \object_create:nnn, \object_create_set:Nnnn, \object_create_gset:Nnnn, \embedded_create:nnn}
% Creates an object from a proxy.
%    \begin{macrocode}

\msg_new:nnnn { rawobjects }{ notproxy }{ Fake ~ proxy }
  {
    Object ~ #1 ~ is ~ not ~ a ~ proxy.
  }

\cs_new_protected:Nn \@@_force_proxy:n
  {
    \object_if_proxy:nF { #1 }
      {
        \msg_error:nnn { rawobjects }{ notproxy }{ #1 }
      }
  }

\cs_new_protected:Nn \@@_create_anon:nnnNN
  {
    \tl_if_empty:nF{ #1 }
    {

    \@@_force_proxy:n { #1 }
	
	
    \object_newconst_str:nnn
      {
        \object_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { M }{ #2 }
    \object_newconst_str:nnn
      {
        \object_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { P }{ #1 }
    \object_newconst_str:nnV
      {
        \object_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { S } #4
    \object_newconst_str:nnV
      {
        \object_embedded_adr:nn{ #3 }{ /_I_/ }
      }
      { V } #5

    \seq_map_inline:cn
      {
        \object_member_adr:nnn { #1 }{ varlist }{ seq }
      }
      {
        \object_new_member:nnv { #3 }{ ##1 }
          {
            \object_ncmember_adr:nnn { #1 }{ ##1 _ type }{ str }
          }
      }
      
    \seq_map_inline:cn
      {
        \object_member_adr:nnn { #1 }{ objlist }{ seq }
      }
      {
        \embedded_create:nvn
          { #3 }
          {
            \object_ncmember_adr:nnn { #1 }{ ##1 _ proxy }{ str }
          }
          { ##1 }
      }

    \tl_map_inline:cn
      {
        \object_member_adr:nnn { #1 }{ init }{ tl }
      }
      {
        ##1 { #1 }{ #2 }{ #3 }
      }

    }
  }
  
\cs_generate_variant:Nn \@@_create_anon:nnnNN { xnxNN, xvxcc }

\cs_new_protected:Nn \object_create:nnnNN
  {
    \@@_create_anon:xnxNN { #1 }{ #2 }
      { \object_address:nn { #2 }{ #3 } }
      #4 #5
  }

\cs_generate_variant:Nn \object_create:nnnNN { VnnNN }

\cs_new_protected:Nn \object_create_set:NnnnNN
  {
    \object_create:nnnNN { #2 }{ #3 }{ #4 } #5 #6
    \str_set:Nx #1 { \object_address:nn { #3 }{ #4 } }
  }

\cs_new_protected:Nn \object_create_gset:NnnnNN
  {
    \object_create:nnnNN { #2 }{ #3 }{ #4 } #5 #6
    \str_gset:Nx #1 { \object_address:nn { #3 }{ #4 } }
  }

\cs_generate_variant:Nn \object_create_set:NnnnNN { NVnnNN, NnnfNN }
\cs_generate_variant:Nn \object_create_gset:NnnnNN { NVnnNN, NnnfNN }



\cs_new_protected:Nn \object_create:nnnN
  {
    \object_create:nnnNN { #1 }{ #2 }{ #3 } #4 \c_object_public_str
  }

\cs_generate_variant:Nn \object_create:nnnN { VnnN }

\cs_new_protected:Nn \object_create_set:NnnnN
  {
    \object_create_set:NnnnNN #1 { #2 }{ #3 }{ #4 } #5 \c_object_public_str
  }

\cs_new_protected:Nn \object_create_gset:NnnnN
  {
    \object_create_gset:NnnnNN #1 { #2 }{ #3 }{ #4 } #5 \c_object_public_str
  }

\cs_generate_variant:Nn \object_create_set:NnnnN { NVnnN }
\cs_generate_variant:Nn \object_create_gset:NnnnN { NVnnN }

\cs_new_protected:Nn \object_create:nnn
  {
    \object_create:nnnNN { #1 }{ #2 }{ #3 }
      \c_object_global_str \c_object_public_str
  }

\cs_generate_variant:Nn \object_create:nnn { Vnn }

\cs_new_protected:Nn \object_create_set:Nnnn
  {
    \object_create_set:NnnnNN #1 { #2 }{ #3 }{ #4 }
      \c_object_global_str \c_object_public_str
  }

\cs_new_protected:Nn \object_create_gset:Nnnn
  {
    \object_create_gset:NnnnNN #1 { #2 }{ #3 }{ #4 }
      \c_object_global_str \c_object_public_str
  }

\cs_generate_variant:Nn \object_create_set:Nnnn { NVnn }
\cs_generate_variant:Nn \object_create_gset:Nnnn { NVnn }



  
\cs_new_protected:Nn \embedded_create:nnn
  {
    \@@_create_anon:xvxcc { #2 }
	  {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { M }{ str }
      }
      {
        \object_embedded_adr:nn
          { #1 }{ #3 }
      }
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { S }{ str }
      }
      {
        \object_ncmember_adr:nnn
          {
            \object_embedded_adr:nn{ #1 }{ /_I_/ }
          }
          { V }{ str }
      }
  }

\cs_generate_variant:Nn \embedded_create:nnn { nvn, Vnn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\proxy_create:nn, \proxy_create_set:Nnn, \proxy_create_gset:Nnn}
%Creates a new proxy object
%    \begin{macrocode}

\cs_new_protected:Nn \proxy_create:nn
  {
    \object_create:VnnNN \c_proxy_address_str { #1 }{ #2 }
      \c_object_global_str \c_object_public_str
  }

\cs_new_protected:Nn \proxy_create_set:Nnn
  {
    \object_create_set:NVnnNN #1 \c_proxy_address_str { #2 }{ #3 }
      \c_object_global_str \c_object_public_str
  }

\cs_new_protected:Nn \proxy_create_gset:Nnn
  {
    \object_create_gset:NVnnNN #1 \c_proxy_address_str { #2 }{ #3 }
      \c_object_global_str \c_object_public_str
  }



\cs_new_protected:Nn \proxy_create:nnN
  {
    \@@_launch_deprecate:NN \proxy_create:nnN \proxy_create:nn
    \object_create:VnnNN \c_proxy_address_str { #1 }{ #2 }
      \c_object_global_str #3
  }

\cs_new_protected:Nn \proxy_create_set:NnnN
  {
    \@@_launch_deprecate:NN \proxy_create_set:NnnN \proxy_create_set:Nnn
    \object_create_set:NVnnNN #1 \c_proxy_address_str { #2 }{ #3 }
      \c_object_global_str #4
  }

\cs_new_protected:Nn \proxy_create_gset:NnnN
  {
    \@@_launch_deprecate:NN \proxy_create_gset:NnnN \proxy_create_gset:Nnn
    \object_create_gset:NVnnNN #1 \c_proxy_address_str { #2 }{ #3 }
      \c_object_global_str #4
  }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\proxy_push_member:nnn}
% Push a new member inside a proxy.
%    \begin{macrocode}

\cs_new_protected:Nn \proxy_push_member:nnn
  {
    \object_newconst_str:nnn { #1 }{ #2 _ type }{ #3 }
    \seq_gput_left:cn
      {
        \object_member_adr:nnn { #1 }{ varlist }{ seq }
      }
      { #2 }
  }

\cs_generate_variant:Nn \proxy_push_member:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\proxy_push_embedded:nnn}
% Push a new embedded object inside a proxy.
%    \begin{macrocode}

\cs_new_protected:Nn \proxy_push_embedded:nnn
  {
    \object_newconst_str:nnx { #1 }{ #2 _ proxy }{ #3 }
    \seq_gput_left:cn
      {
        \object_member_adr:nnn { #1 }{ objlist }{ seq }
      }
      { #2 }
  }

\cs_generate_variant:Nn \proxy_push_embedded:nnn { Vnn }

%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\proxy_add_initializer:nN}
% Push a new embedded object inside a proxy.
%    \begin{macrocode}

\cs_new_protected:Nn \proxy_add_initializer:nN
  {
    \tl_gput_right:cn
      {
        \object_member_adr:nnn { #1 }{ init }{ tl }
      }
      { #2 }
  }

\cs_generate_variant:Nn \proxy_add_initializer:nN { VN }

%    \end{macrocode}
%\end{macro}
%
%\begin{variable}{\c_proxy_address_str}
% Variable containing the address of the \verb|proxy| object.
%    \begin{macrocode}

\str_const:Nx \c_proxy_address_str
  { \object_address:nn { rawobjects }{ proxy } }
  
\object_newconst_str:nnn
  {
    \object_embedded_adr:Vn \c_proxy_address_str { /_I_/ }
  }
  { M }{ rawobjects }

\object_newconst_str:nnV
  {
    \object_embedded_adr:Vn \c_proxy_address_str { /_I_/ }
  }
  { P } \c_proxy_address_str
  
\object_newconst_str:nnV
  {
    \object_embedded_adr:Vn \c_proxy_address_str { /_I_/ }
  }
  { S } \c_object_global_str

\object_newconst_str:nnV
  {
    \object_embedded_adr:Vn \c_proxy_address_str { /_I_/ }
  }
  { V } \c_object_public_str


\@@_initproxy:VnV \c_proxy_address_str { rawobjects } \c_proxy_address_str

\object_new_member:Vnn \c_proxy_address_str { init }{ tl }

\object_new_member:Vnn \c_proxy_address_str { varlist }{ seq }

\object_new_member:Vnn \c_proxy_address_str { objlist }{ seq }

\proxy_push_member:Vnn \c_proxy_address_str
  { init }{ tl }
\proxy_push_member:Vnn \c_proxy_address_str
  { varlist }{ seq }
\proxy_push_member:Vnn \c_proxy_address_str
  { objlist }{ seq }

\proxy_add_initializer:VN \c_proxy_address_str
  \@@_initproxy:nnn

%    \end{macrocode}
%\end{variable}
%
% \begin{macro}{\object_allocate_incr:NNnnNN, \object_gallocate_incr:NNnnNN, \object_allocate_gincr:NNnnNN, \object_gallocate_gincr:NNnnNN}
% Create an address and use it to instantiate an object
%    \begin{macrocode}

\cs_new:Nn \@@_combine_aux:nnn
  {
    anon . #3 . #2 . #1
  }

\cs_generate_variant:Nn \@@_combine_aux:nnn { Vnf }

\cs_new:Nn \@@_combine:Nn
  {
    \@@_combine_aux:Vnf #1 { #2 }
	  {
	    \cs_to_str:N #1
	  }
  }

\cs_new_protected:Nn \object_allocate_incr:NNnnNN
  {
    \object_create_set:NnnfNN #1 { #3 }{ #4 }
      {
        \@@_combine:Nn #2 { #3 }
      }
      #5 #6

      \int_incr:N #2
  }

\cs_new_protected:Nn \object_gallocate_incr:NNnnNN
  {
    \object_create_gset:NnnfNN #1 { #3 }{ #4 }
      {
        \@@_combine:Nn #2 { #3 }
      }
      #5 #6

      \int_incr:N #2
  }

\cs_generate_variant:Nn \object_allocate_incr:NNnnNN { NNVnNN }

\cs_generate_variant:Nn \object_gallocate_incr:NNnnNN { NNVnNN }

\cs_new_protected:Nn \object_allocate_gincr:NNnnNN
  {
    \object_create_set:NnnfNN #1 { #3 }{ #4 }
      {
        \@@_combine:Nn #2 { #3 }
      }
      #5 #6

      \int_gincr:N #2
  }

\cs_new_protected:Nn \object_gallocate_gincr:NNnnNN
  {
    \object_create_gset:NnnfNN #1 { #3 }{ #4 }
      {
        \@@_combine:Nn #2 { #3 }
      }
      #5 #6

      \int_gincr:N #2
  }

\cs_generate_variant:Nn \object_allocate_gincr:NNnnNN { NNVnNN }

\cs_generate_variant:Nn \object_gallocate_gincr:NNnnNN { NNVnNN }

%    \end{macrocode}
% \end{macro}
%
%
%\begin{macro}{\object_assign:nn}
%Copy an object to another one.
%    \begin{macrocode}
\cs_new_protected:Nn \object_assign:nn
  {
    \seq_map_inline:cn
      {
        \object_member_adr:vnn
          {
            \object_ncmember_adr:nnn
              {
                \object_embedded_adr:nn{ #1 }{ /_I_/ }
              }
              { P }{ str }
          }
          { varlist }{ seq }
      }
      {
        \object_member_set_eq:nnc { #1 }{ ##1 }
          {
            \object_member_adr:nn{ #2 }{ ##1 }
          }
      }
  }

\cs_generate_variant:Nn \object_assign:nn { nV, Vn, VV }
%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%\end{implementation}
%
%\PrintIndex



